[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "In the West Bank of the Jordan River, Israel continues to encroach on Palestinian land by establishing illegal outposts, transforming them into settlements, and eventually legalizing them. The objective of this application is to detect these outposts and early settlements. Many journalists and researchers hope to mitigate the situation of Palestinian victimization through early intervention and raise public awareness about the status of Palestine beyond Gaza. However, they often manually search for these targets on satellite images. We hope to help them quickly locate these targets through this application.\nThis application initially uses the Soil-Adjusted Vegetation Index (SAVI) to identify target land types, then employs change detection to identify newly cultivated land plots that appear each year. These plots include changes in desert areas and minor agricultural land developments. Therefore, it is necessary to use graphic filtering to select plots of specific areas and shapes, and subsequently pinpoint their central locations. Finally, we attempt to distinguish whether these plots belong to Israel through machine learning.\n\n\nThe hot war in Gaza is well known in the Israeli-Palestinian conflict, but the slow erosion of the West Bank has received little attention. Therefore, we hope to use this application to help relevant users quickly obtain real-time changes in Israel’s occupation of Palestine.\nThe aim of this application is to use satellite imagery to find and mark all Israeli outposts and emerging settlements within the West Bank. For target users, they can quickly query the location and number of these newly emerged territorial encroachments.\n\n\n\nJournalists, researchers and international organizations.\nIsraeli settlements are illegal. Usually when settlements develop to a certain scale, Israel will declare them legal. Early detection can help the international community intervene earlier. Some reporters did a manual blanket search through Google Earth. We hope this helps them resolve the issue quickly.\n\n\n\nHarmonized Sentinel-2 MSI: MultiSpectral Instrument, Level-2A.\nRelated shp files for the Palestinian Israel area\n\n\n\n\nLand Cover Classification(Random Forest), Feature Selection(NDVI, NDBI, SAVI)\nChange detection\nMorphological Analysis, Area and Shape Filtering\nClassification(Support Vector Machine, Random Forest)\n\n\n\n\nThe main function is to provide relevant points to help users quickly locate the latest settlements or outposts. Users can select point options and a specific year to obtain the target position for that year. We also provide quantitative statistics and line charts to help users understand their changing trends.\nAdditionally, users can select other options such as West Bank borders, Palestinian-controlled areas, Israeli-controlled areas, etc. We also provide layers of some analysis processes to help users better understand the working principle of the application. Users can freely view these layers, such as SAVI analysis results, etc.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst, we extract satellite images from Sentinel-2 and filtering out cloud-obscured ones. These images are then subjected to machine learning analysis to identify surface features such as roads, farmland, forests, cities, and bare land. Various feature collections are imported to provide essential geographical context, including West Bank borders, Palestinian and Israeli-Palestinian control areas, and points indicating illegal appropriation.\n// Import West Bank borders.\nvar westbank = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/WestBankBorder\");\n\n// Import Palestinian control area.\nvar areaA = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaA\");\n\n// Import Israeli-Palestinian control area.\nvar areaB = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaB\");\n\nvar redpoint=ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/illegal_appropriation\")\n\n// Date range.\nvar start='2023-04-01';\nvar end='2024-04-01';\n\n// Bands.\nvar bands = ['B2','B3','B4','B5','B6','B7','B8','B8A','B11','B12'];\n  \n// Filter the Sentinel-2 collection and select the less cloudy image.\nvar sentinel  = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') \n              .filter(ee.Filter.date(start, end))\n              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n              .mean()\n              .select(bands);\n\n// Visualization of sentinel.\nvar sentinel_settings = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nMap.addLayer(sentinel.clip(AOI), sentinel_settings, 'Sentinel',false);\n\n// Visualization of westbank borders.\nvar westbank_settings = {\n  color: 'FFFFFF',\n  fillColor: '00000000',\n};\n\nMap.addLayer(westbank, westbank_settings, 'West Bank Border');\n\n// Study area.\nvar study_area = areaA.merge(areaB);\nvar study_geometry = study_area.union().geometry();\nvar buffered_geometry = study_geometry.buffer(200);\n\nMap.addLayer(buffered_geometry, {color: 'yellow'}, 'Study Area',false);\nTwo crucial functions are defined: one calculates the Soil Adjusted Vegetation Index (SAVI), and the other retrieves yearly Sentinel-2 images for analysis over time.\n// Function for calculating SAVI.\nfunction SAVI(image) {\n  // Clip area.\n  var sentinel_westbank = image.clip(westbank);\n  var sentinel_study = image.clip(buffered_geometry);\n  \n  // Calculate SAVI.\n  var savi = sentinel_westbank.expression(\n    '(NIR - RED) / (NIR + RED + 0.5) * (1 + 0.5)', {\n      'NIR': sentinel_westbank.select('B8'),\n      'RED': sentinel_westbank.select('B4')\n    }\n  ).rename('SAVI');\n\n  var barelandSAVI = savi.lt(0.2);\n  \n  return barelandSAVI;\n}\n\nfunction YearlyImages(startYear, endYear, dateSuffix, bands) {\n  // Initialize an empty dictionary to store a set of images by year.\n  var yearly_sentinel_images = ee.Dictionary();\n\n  // Loop through each year from startYear to endYear.\n  for (var year = startYear; year &lt;= endYear; year++) {\n    var start = year + dateSuffix;\n    var end = (year + 1) + dateSuffix;\n\n    var sentinel = ee.ImageCollection('COPERNICUS/S2_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n\n    yearly_sentinel_images = yearly_sentinel_images.set(year.toString(), sentinel);\n  }\n\n  return yearly_sentinel_images;\nThese yearly images are iterated over, with the SAVI function applied to each, and the resulting bare land distribution is visualized on the map, offering insights into land use changes.\n// Create yearly images.\nvar sentinel_2017_2023 = YearlyImages(2017, 2023, '-04-01', bands);\n\n// Iterate over the dictionary and apply SAVI function.\nvar savi_2017_2023 = ee.Dictionary();\nvar keys = sentinel_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var image = ee.Image(sentinel_2017_2023.get(key));\n  var savi_image = SAVI(image);\n  savi_2017_2023 = savi_2017_2023.set(key, savi_image);// savi_2015_2023 is the dictionary for Change detection.\n});\n\n// Visualization.\nvar visParams = {\n  min: 0.0,\n  max: 1.0,\n  palette: ['2a2A28', 'FF0000']\n};\n\nvar keys = savi_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var savi_image = ee.Image(savi_2017_2023.get(key));\n  Map.addLayer(savi_image, visParams, 'SAVI_' + key,false);\n});\nAdditionally, a function called calculateChange is defined, which computes differences in bare land between consecutive years, aiding in identifying new roads or settlements. This function iterates from 2017 to 2022, analyzing each yearly pair and visualizing the changes for deeper understanding.\n// Function to calculate change between two images\nfunction calculateChange(image1, image2, year1, year2) {\n  // Calculate the difference between the two images\n  var diff = image2.subtract(image1).abs(); // Taking absolute value of the difference\n  \n  // Visualize the change\n  var layerName = 'Change ' + year1 + ' to ' + year2;\n  Map.addLayer(diff, {min: 0, max: 0.5, palette: ['2A2A28', 'FF0000']}, layerName);\n}\n\n// Iterate over the years and calculate change\nfor (var i = 2017; i &lt; 2023; i++) {\n  var image1 = ee.Image(savi_2017_2023.get(i.toString()));\n  var image2 = ee.Image(savi_2017_2023.get((i + 1).toString()));\n  \n  calculateChange(image1, image2, i, i + 1);\n}\n\n\n\nThis section is specifically designed to screen, monitor, and analyze areas where the Soil Adjustment Vegetation Index (SAVI) has decreased over several consecutive years. It starts by identifying areas between adjacent years where the SAVI value has decreased, in order to determine regions of vegetation loss, especially those transitioning from above 0.2 in SAVI to below 0.2. After these changes are identified, the code applies specific filtering functions to exclude smaller patches, thereby reducing noise and errors to ensure the reliability and accuracy of the results. The filtered areas are displayed in red on the map for direct visualization and analysis. Moreover, the code vectorizes these areas and extracts centroids highlighted in yellow, which are crucial for further geospatial analysis. Ultimately, these centroids and areas are added to the map.\n//  ---------------------------Part 4: Change filter ---------------------------\n// Filter out small patches based on connected pixel size.\nfunction filterSmallPatches(image, minPixels) {\n  var connected = image.connectedPixelCount();\n  return image.updateMask(connected.gte(minPixels));\n}\n\n// Function to compare SAVI between two consecutive years, identify changes, and filter small patches.\nfunction compareAndFilterYearlySAVI(yearlyImages, startYear, endYear, minPixels) {\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filtered_change = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create a visualization layer to show these changes.\n    var changeVisualization = filtered_change.updateMask(filtered_change)\n                                             .multiply(255)\n                                             .toByte();\n    var changeParams = {\n      min: 0,\n      max: 255,\n      palette: ['000000', 'FF0000']  // Display changes in red.\n    };\n\n    Map.addLayer(changeVisualization, changeParams, 'Filtered Change to Barren ' + year + '-' + (year+1));\n  }\n}\n\n// Apply the function to compare and filter SAVI across years and visualize changes.\ncompareAndFilterYearlySAVI(savi_2017_2023, 2017, 2023, 100);\n\n\n\n// Function to compare SAVI between two consecutive years, identify changes, filter small patches, and extract centroids.\nfunction compareFilterAndExtractCentroids(yearlyImages, startYear, endYear, minPixels) {\n  var changeLayersDict = {}; // Dictionary to hold change layers\n  var centroidLayersDict = {}; // Dictionary to hold centroid layers\n\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased from above 0.2 to below 0.2.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filteredChange = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create vectors from the filtered change areas.\n    var vectors = filteredChange.reduceToVectors({\n      reducer: ee.Reducer.countEvery(),\n      geometry: study_geometry,\n      scale: 30,\n      maxPixels: 1e13\n    });\n\n    // Extract centroids of the vectors.\n    var centroids = vectors.map(function(feature) {\n      return feature.geometry().centroid();\n    });\n\n    // Add vectors and centroids to their respective dictionaries.\n    changeLayersDict[year] = filteredChange;\n    centroidLayersDict[year] = centroids;\n  }\n  return {changeLayers: changeLayersDict, centroidLayers: centroidLayersDict};\n}\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Example: Add the centroid layers for specific years to the map.\nMap.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\nMap.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\nMap.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\nMap.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\nMap.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\nMap.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n\n\nIn this part, we innovatively propose using machine learning to identify Israel building clusters.\nFirstly, let’s conduct a preliminary land screening on the West Bank of the Jordan River.\n// Pre-Processing\n\n// Calculate GLCM\nvar glcm=sentinel.toUint16().select('B8').glcmTexture({size: 4})\n\n// Calculate NDWI\nvar ndwi=sentinel.normalizedDifference(['B3','B8'])\n                  .select(['nd'],['ndwi']);\n                  \n// Calculate NDVI                 \nvar ndvi=sentinel.normalizedDifference(['B8','B4'])\n                  .select(['nd'],['ndvi']);\n\n// Calculate NDBI                 \nvar ndbi=sentinel.normalizedDifference(['B11','B8'])\n                  .select(['nd'],['ndbi']);\n                  \n// Clip the map\nvar westbankborder = sentinel.clip(westbank);\n\n// Update the mask\nvar westbank_image= westbankborder\n                  .updateMask(ndwi.lt(0.3))\n                  .updateMask(ndvi.lt(0.2))\n                  .updateMask(ndbi.gt(0.1))\n                  .addBands(glcm)\n                  .addBands(ndbi)\n                  .select(bands);\n                  \n// Display the results\nMap.centerObject(westbank, 8);  // Center the map on the certain area with an appropriate zoom level\nMap.addLayer(westbank_image, {bands: ['B4', 'B3', 'B2'], max: 2000}, 'westbankborder');\nThen, we manually annotated Israeli and Palestinian building clusters. During this process, we made an unexpected discovery that the newly developed lands were developed by Israel, and due to resource constraints, it would be impossible for Palestine to engage in new land excavation. To enhance precision, we also marked desert areas due to the difficulty in distinguishing them from buildings using the NDVI and NDBI.\nTherfore, we divided three classes: Class 1: is Israel building clusters Class 2: is Palestinian building clusters Class3: is the desert areas\n// Generating Labeled Data\n\n// Take random samples of points from within these polygons\n\n// Take points in each polygon\nvar points_in_Israeli = mergedAreas1235.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 250)\n  .map(function(point) {\n    return point.set({'class': 0});\n });\n}).flatten();\n\nvar points_outside_Israeli = Outside_Israeli.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 400)\n  .map(function(point) {\n    return point.set({'class': 1});\n });\n}).flatten();\n\nvar desert_points = Desert_Areas.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 1080)\n  .map(function(point) {\n    return point.set({'class': 2});\n  });\n}).flatten();\n\n// Create one feature collection\nvar Israeli_points = ee.FeatureCollection([points_in_Israeli,\n                                  points_outside_Israeli,\n                                  desert_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();    \n                                  \n// Create a sample dataset from the merged marked area\nvar split=0.7\nvar training_samples = Israeli_points.filter(ee.Filter.lt('random', split));\nvar validation_sample = Israeli_points.filter(ee.Filter.gte('random', split));\n\n// Obtain training set\nvar training = westbank_image.sampleRegions({\n  collection: training_samples,\n  properties: ['class'],\n  scale: 10,\n});\n\n// Obtain validation set\nvar validation = westbank_image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// Select classification features and training classifiers\nvar model = ee.Classifier.smileRandomForest(500)\n                         .train(training, 'class');\n\nprint('Training class 0:', training_samples.filter(ee.Filter.eq('class', 0)).size());\nprint('Training class 1:', training_samples.filter(ee.Filter.eq('class', 1)).size());\nprint('Training class 2:', training_samples.filter(ee.Filter.eq('class', 2)).size());\nprint('Validation class 0:', validation_sample.filter(ee.Filter.eq('class', 0)).size());\nprint('Validation class 1:', validation_sample.filter(ee.Filter.eq('class', 1)).size());\nprint('Validation class 2:', validation_sample.filter(ee.Filter.eq('class', 2)).size());\n\n// Make prediction\nvar prediction = westbank_image.classify(model);\n\n// Select Israeli architectural complex\nvar Israeli_prediction=prediction.updateMask(prediction.eq(0));\n\n// Add layer\nMap.addLayer(Israeli_prediction, {palette:'red'}, 'Predicted Israeli Architectural Complex');\n\n// Validate the model with the validation dataset and classify the samples\nvar validated = validation.classify(model);\n\n// Compute the error matrix for the validation results to assess the accuracy\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\n// Print the confusion matrix to the console for evaluation\nprint('Confusion Matrix ', testAccuracy);\nThe model’s accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.\nAll in all, the model shows potential in identifying Israeli building clusters. By combining historical Israel’s exploitation of vacant land and identifying Israel based on historical data, illegal encroachments can be identified.\n\n\n\nThis code segment primarily establishes and configures a user interface (UI) panel for interactively displaying and managing map layers. The panel allows users to select from various map layers such as “West Bank Border,” “SAVI” (Soil Adjusted Vegetation Index), “Change Detection,” and “Predicted Israeli Architectural Complex” through a dropdown menu. The interface updates the displayed map layers and associated information based on the user’s selection.\nAdditionally, the panel includes a slider for selecting years, which influences the displayed content of map layers, such as SAVI indices or change detection results. Moreover, the panel supports the display of additional control elements like information buttons and year labels, which are displayed conditionally depending on the currently selected map layer.\nThere’s also an information panel used to display more detailed descriptions or data, such as error matrices. These controls are dynamically managed through written functions, such as showing and hiding specific controls, updating map layers, or handling map click events, thereby enhancing user interaction.\n \n// ---------------------------Part 5: create UI Panel---------------------------\nvar panel = ui.Panel();\npanel.style().set({\n  width: '400px',\n  padding: '8px'\n});\nui.root.insert(0, panel);\n\n// Layer select change event handler\nvar layerSelect = ui.Select({\n  items: ['West Bank Border', 'SAVI', 'Change detection', 'Predicted Israeli Architectural Complex','Barren Centers','Built-Up Centers'],\n  onChange: handleLayerChange\n});\n\n// Function to handle layer changes\nfunction handleLayerChange(selected) {\n  currentLayer = selected;\n  var showSlider = selected === 'SAVI' || selected === 'Change detection' || selected === 'Built-Up Centers' || selected === 'Barren Centers';\n  var showChart = selected === 'SAVI'; // Only show chart for SAVI layer\n  var showLabels = selected === 'SAVI' || selected === 'Change detection' || selected === 'Built-Up Centers' || selected === 'Barren Centers';\n  var showInfoButton = selected === 'Predicted Israeli Architectural Complex';\n\n  // Update the visibility of UI components\n  //toggleInfoButton.style().set('shown', showInfoButton);\n  updateLabelPanelVisibility(showLabels);\n  yearSlider.style().set('shown', showSlider);\n  yearLabel.style().set('shown', showSlider);\n  \n  // Reset and update map layers\n  Map.layers().reset();\n  updateMapLayers(selected);\n\n  // Update the display of charts\n  if (showChart) {\n    updateChart(yearSlider.getValue());\n  } else {\n    clearChart();\n  }\n\n  // Display the confusion matrix if required\n  if (selected === 'Predicted Israeli Architectural Complex'){\n      var errorMatrix = validated.errorMatrix('class', 'classification');\n      displayConfusionMatrix(errorMatrix);\n  }\n  \n  if (selected === 'Change detection'){\n    \n    var description = ui.Label('We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.');\n    panel.add(description);  // Add the description\n    currentWidgets.push(description);\n  \n  }\n  if (selected === 'SAVI'){\n    \n    var savidescription = ui.Label('Through SAVI, we can find all the bare land stocks in the corresponding year. Zooming in on the image we can see plots of different sizes and shapes. After excluding fragmented farmland and huge areas of desert, the large-scale plots are likely to be new construction sites.');\n    panel.add(savidescription);  // Add the description\n    currentWidgets.push(savidescription);\n    panel.add(toggleRegionButton);  // Add the description\n    currentWidgets.push(toggleRegionButton);\n  \n  }\n}\n\n// Add controls to the panel\npanel.add(ui.Label('Layer Selector:', {fontWeight: 'bold'}));\npanel.add(layerSelect);\n\nvar currentWidgets = [];  // Array to store current widgets for easy removal\n\n// Create a slider to select the year\nvar yearSlider = ui.Slider({\n  min: 2017,\n  max: 2023,\n  value: 2017,\n  step: 1,\n  style: {stretch: 'horizontal', shown: false}\n});\nvar yearLabel = ui.Label('Current Year:', {fontWeight: 'bold', shown: false});\npanel.add(yearLabel);\npanel.add(yearSlider);\n\n// Create year labels\nvar yearLabels = {\n  '2017': '2017',\n  '2018': '2018',\n  '2019': '2019',\n  '2020': '2020',\n  '2021': '2021',\n  '2022': '2022',\n  '2023': '2023'\n};\n\n// Create a panel for year labels, initially not shown\nvar labelPanel = ui.Panel({\n  widgets: Object.keys(yearLabels).map(function(year) {\n    return ui.Label(yearLabels[year], {shown: false});\n  }),\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', textAlign: 'justify-between', shown: false}\n});\npanel.add(labelPanel);\n\n// Create an info panel\nvar infoPanel = ui.Panel({\n  style: {\n    position: 'bottom-left',\n    width: '300px',\n    maxHeight: '400px',\n    padding: '8px',\n    backgroundColor: 'white',\n    shown: false\n  }\n});\n\n// Create a button to toggle the display of information\nvar toggleInfoButton = ui.Button({\n  label: 'Show/Hide Information',\n  onClick: function() {\n    var shown = infoPanel.style().get('shown');\n    infoPanel.style().set('shown', !shown);\n  },\n  style: {\n    shown: false\n  }\n});\npanel.add(toggleInfoButton);\n\n// Function to update the visibility of the label panel\nfunction updateLabelPanelVisibility(visible) {\n  labelPanel.widgets().forEach(function(label) {\n    label.style().set('shown', visible);\n  });\n  labelPanel.style().set('shown', visible);\n}\n\n// Global variable to keep track of the current selected layer\nvar currentLayer = '';\n\nvar saviregion\n// Start with study_area as the default active region\nvar activeGeometry = study_area;\n// Button to toggle between study_area and saviregion\nvar toggleRegionButton = ui.Button('Toggle Geometry');  // Initial label setup\n\ntoggleRegionButton.onClick(function() {\n  // Toggle the active geometry\n  activeGeometry = (activeGeometry === study_area) ? saviregion : study_area;\n  \n  // Update the label of the button\n  var newLabel = 'Active Geometry: ' + (activeGeometry === study_area ? 'Study Area' : 'SAVI Region');\n  toggleRegionButton.setLabel(newLabel);\n\n  // Recalculate counts when the geometry is toggled\n  //calculateSAVI1Counts();\n});\n\n// Global variable to store the reference of the clicked point layer\nvar clickedPointLayer = null;\n\nfunction mapClickHandler(coords) {\n  var point = ee.Geometry.Point([coords.lon, coords.lat]);\n\n  // Adjust this buffer radius as needed or use it directly for point-based analysis\n  saviregion = point.buffer(1000);  // 1000 meter buffer around the clicked point\n\n  // Clear previous clicked point from the map (optional)\n  if (clickedPointLayer !== null) {\n    Map.layers().remove(clickedPointLayer);\n  }\n\n  // Define the style for the point\n  var pointStyle = {color: 'green', fillColor: '00000000'};\n\n  // Add the point to the map with style\n  clickedPointLayer = Map.addLayer(point, pointStyle, 'Clicked Point');\n\n  // Additional actions based on current layer type\n  if (currentLayer === 'SAVI') {\n    var saviImage = ee.Image(savi_2017_2023.get(yearSlider.getValue().toString()));\n    // Further processing or layer addition can be handled here\n  }\n}\n\n// Register map click event\nMap.onClick(mapClickHandler);\n\nfunction resetYearselector() {\n      panel.remove(yearLabel);\n      panel.remove(yearSlider);\n      panel.add(yearLabel);\n      panel.add(yearSlider);\n}\n\n// Function used to update the map display based on the selected layer\nfunction updateMapLayers(selected) {\n  Map.layers().reset();\n  Map.setOptions(\"satellite\");\n  var darkLayer = ee.Image.constant(0).visualize({palette: ['000000'], opacity: 0.5}); \n  Map.addLayer(darkLayer, {}, 'Dark Layer');\n  Map.setZoom(13);\n  removeChart();\n  var year = yearSlider.getValue();\n  // Clear specific widgets related to the confusion matrix\n        currentWidgets.forEach(function(widget) {\n            panel.remove(widget);\n        });\n        currentWidgets = [];  // Reset the widget tracker\n  switch (selected) {\n    case 'West Bank Border':\n      Map.addLayer(westbank, westbank_settings, 'West Bank Border');\n      break;\n    case 'SAVI':\n      //clearChart();\n      resetYearselector();\n      var savi_image = ee.Image(savi_2017_2023.get(yearSlider.getValue().toString()));\n      Map.addLayer(savi_image, visParams, 'SAVI_' + yearSlider.getValue().toString());\n      break;\n    case 'Change detection':\n      //clearChart();\n      var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n      currentWidgets.push(description);\n      resetYearselector();\n      if (year &gt; 2017) {\n        var image1 = ee.Image(savi_2017_2023.get((year - 1).toString()));\n        var image2 = ee.Image(savi_2017_2023.get(year.toString()));\n        calculateChange(image1, image2, year - 1, year);\n      }\n      break;\n    case 'Predicted Israeli Architectural Complex':\n      Map.addLayer(Israeli_prediction, {palette: 'red'}, 'Predicted Israeli Architectural Complex',true);\n      break;\n    case 'Built-Up Centers':\n      //clearChart();\n      var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n      currentWidgets.push(description);\n      resetYearselector();\n      //classifyAndVisualizeCenters(savi_2017_2023, year, year + 1, 100);\n      // Example: Add the centroid layers for specific years to the map.\n     Map.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\n     Map.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\n     Map.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\n     Map.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\n     Map.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\n     Map.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n\n\n      break;\n    case 'Barren Centers':\n      //clearChart();\n      var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n      currentWidgets.push(description);\n      resetYearselector();\n      Map.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\n      Map.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\n      Map.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\n      Map.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\n      Map.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\n      Map.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n      //classifyAndVisualizeCenters(savi_2017_2023, year, year + 1, 100);\n      break;\n  }\n\n}\n\nui.root.add(infoPanel);\nvar errorMatrix = validated.errorMatrix('class', 'classification');\n\n// Default display of the initial year's layer\nupdateMapLayers('SAVI');\nlayerSelect.setValue('SAVI', true);\n\n// Function to update or clear chart based on current layer\n// Calculate the number of pixels with SAVI=1 for each year from 2017 to 2023 and add a line chart to the existing panel\n\nvar savedChart;\nfunction calculateSAVI1Counts() {\n  var counts = []; // Array to store counts for each year\n\n  // Iterate through each year\n  for (var year = 2017; year &lt;= 2023; year++) {\n    var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n\n    // Create a mask for SAVI values equal to 1\n    var mask1 = selectedYearImage.eq(1);\n\n    // Apply the mask\n    var image1 = selectedYearImage.updateMask(mask1);\n\n    // Calculate the number of pixels with SAVI value equal to 1\n    var countPixels1 = image1.reduceRegion({\n      reducer: ee.Reducer.count(),\n      geometry: activeGeometry,\n      scale: 30,\n      maxPixels: 1e9\n    });\n\n    // Add each year's result to the array\n    counts.push({\n      'year': year,\n      'count': countPixels1.get('SAVI')\n    });\n  }\n\n  // Convert the results array to a FeatureCollection\n  var countFeatures = ee.FeatureCollection(counts.map(function(item) {\n    return ee.Feature(null, item);\n  }));\n\n  // Create a line chart\n  var countChart = ui.Chart.feature.byFeature({\n    features: countFeatures,\n    xProperty: 'year',\n    yProperties: ['count']\n  })\n  .setOptions({\n    title: 'SAVI = 1 Pixel Counts from 2017 to 2023',\n    hAxis: {title: 'Year'},\n    vAxis: {title: 'Count of Pixels'},\n    lineWidth: 1,\n    pointSize: 3\n  });\n\n  // Add the chart to the existing panel\n  panel.widgets().add(countChart);\n  savedChart = countChart;\n}\n\n// Function to remove the chart\nfunction removeChart() {\n  if (savedChart) {\n    panel.widgets().remove(savedChart);\n    savedChart = null; // Clear the reference, indicating that there is currently no chart\n  }\n}\n\nfunction updateChart(year) {\n  var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n\n  // Create masks for SAVI values 0 and 1\n  var mask0 = selectedYearImage.eq(0);\n  var mask1 = selectedYearImage.eq(1);\n\n  // Apply masks to the original image\n  var image0 = selectedYearImage.updateMask(mask0);\n  var image1 = selectedYearImage.updateMask(mask1);\n\n  // Generating a histogram for SAVI values\n  var histogramChart = ui.Chart.image.histogram({\n    image: ee.Image.cat([image0.select('SAVI'), image1.select('SAVI')]),\n    region: activeGeometry,\n    scale: 30,\n    minBucketWidth: 0.001,  // Each bucket corresponds exactly to one SAVI value\n  }).setOptions({\n    title: year + ' SAVI Value Distribution',\n    vAxis: {title: 'Pixel Count'},\n    hAxis: {title: 'SAVI', ticks: [{v:0, f:'0'}, {v:1, f:'1'}]}, // Explicitly show only 0 and 1\n    series: {\n      0: {color: 'blue', label: 'SAVI = 0'},  // Color and label for SAVI value 0\n      1: {color: 'red', label: 'SAVI = 1'}    // Color and label for SAVI value 1\n    },\n    bar: {groupWidth: \"20%\"}  // Adjust the width of the bars\n  });\n\n  // Count and print the number of pixels with SAVI = 1\n  var countPixels1 = image1.reduceRegion({\n    reducer: ee.Reducer.count(),\n    geometry: activeGeometry,\n    scale: 30,\n    maxPixels: 1e9\n  });\n\n  // Check if there is already a chart at the expected position in the panel and replace it or add the new chart.\n  if (panel.widgets().length() &gt; 2) {\n    panel.widgets().set(2, histogramChart); // Replace the existing chart\n  } else {\n    panel.widgets().insert(2, histogramChart); // Add the chart if not already present\n  }\n  //panel.widgets().remove(countChart);\n  calculateSAVI1Counts();\n}\n\n// Function to clear the chart\nfunction clearChart() {\n  if (panel.widgets().length() &gt; 2) {\n    panel.remove(panel.widgets().get(2));  // Remove the chart widget\n  }\n}\n\n// Slider event handling\nyearSlider.onSlide(function(value) {\n  yearLabel.setValue('Current Year: ' + value);\n\n  // Updates the current layer, which may affect charts, map layers, and descriptions\n  updateMapLayers(currentLayer);\n\n  // If the current layer requires a specific description, it is handled here\n  if (currentLayer === 'SAVI') {\n    updateChart(value); // Update chart only if SAVI is currently selected\n    updateDescriptionForSAVI();\n  } else if (currentLayer === 'Change detection') {\n    updateDescriptionForChangeDetection();\n  } else if (currentLayer === 'Predicted Israeli Architectural Complex') {\n    updateDescriptionForPredictedIsraeliArchitecturalComplex();\n  } else if (currentLayer === 'Built-Up Centers' || currentLayer === 'Barren Centers') {\n    updateDescriptionForCenters();\n  }\n});\n\n// Helper functions to manage descriptions for different layers\nfunction updateDescriptionForSAVI() {\n  clearDescriptions();\n  var description = ui.Label('Through SAVI, we can find all the bare land stocks in the corresponding year. Zooming in on the image we can see plots of different sizes and shapes. After excluding fragmented farmland and huge areas of desert, the large-scale plots are likely to be new construction sites.');\n  panel.add(description);\n  // Add the button to the UI Panel\n  panel.add(toggleRegionButton);\n  currentWidgets.push(description,toggleRegionButton);\n}\n\nfunction updateDescriptionForChangeDetection() {\n  clearDescriptions();\n  var description = ui.Label('We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.');\n  panel.add(description);\n  currentWidgets.push(description);\n}\n\nfunction updateDescriptionForPredictedIsraeliArchitecturalComplex() {\n  clearDescriptions();\n  var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n  panel.add(description);\n  currentWidgets.push(description);\n}\n\nfunction updateDescriptionForCenters() {\n  clearDescriptions();\n  var description = ui.Label('Through this view, we can analyze the urban development over the years.');\n  panel.add(description);\n  currentWidgets.push(description);\n}\n\n// Function to clear previously added descriptions\nfunction clearDescriptions() {\n  currentWidgets.forEach(function(widget) {\n    panel.remove(widget);\n  });\n  currentWidgets = [];  // Reset the widget tracker\n}\n\n// Function to display confusion matrix\nfunction displayConfusionMatrix(errorMatrix) {\n  // Clear previously added widgets from the panel\n  currentWidgets.forEach(function(widget) {\n        panel.remove(widget);\n    });\n  currentWidgets = [];  // Reset the array after clearing\n  var matrixArray = errorMatrix.array();\n  var matrixChart = ui.Chart.array.values({\n    array: matrixArray,\n    axis: 0,\n    xLabels: errorMatrix.order()\n  }).setChartType('Table').setOptions({\n    title: 'Confusion Matrix',\n    hAxis: {title: 'Predicted Label'},\n    vAxis: {title: 'Actual Label'},\n    colors: ['yellow', 'red', 'green']\n  });\n\n  // Add chart description\n  var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n  //panel.clear();  // Clear previous elements in the panel\n  panel.add(description);  // Add the description\n  panel.add(matrixChart);  // Display the chart\n  currentWidgets.push(description, matrixChart);  // Store references to remove later\n}"
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "In the West Bank of the Jordan River, Israel continues to encroach on Palestinian land by establishing illegal outposts, transforming them into settlements, and eventually legalizing them. The objective of this application is to detect these outposts and early settlements. Many journalists and researchers hope to mitigate the situation of Palestinian victimization through early intervention and raise public awareness about the status of Palestine beyond Gaza. However, they often manually search for these targets on satellite images. We hope to help them quickly locate these targets through this application.\nThis application initially uses the Soil-Adjusted Vegetation Index (SAVI) to identify target land types, then employs change detection to identify newly cultivated land plots that appear each year. These plots include changes in desert areas and minor agricultural land developments. Therefore, it is necessary to use graphic filtering to select plots of specific areas and shapes, and subsequently pinpoint their central locations. Finally, we attempt to distinguish whether these plots belong to Israel through machine learning.\n\n\nThe hot war in Gaza is well known in the Israeli-Palestinian conflict, but the slow erosion of the West Bank has received little attention. Therefore, we hope to use this application to help relevant users quickly obtain real-time changes in Israel’s occupation of Palestine.\nThe aim of this application is to use satellite imagery to find and mark all Israeli outposts and emerging settlements within the West Bank. For target users, they can quickly query the location and number of these newly emerged territorial encroachments.\n\n\n\nJournalists, researchers and international organizations.\nIsraeli settlements are illegal. Usually when settlements develop to a certain scale, Israel will declare them legal. Early detection can help the international community intervene earlier. Some reporters did a manual blanket search through Google Earth. We hope this helps them resolve the issue quickly.\n\n\n\nHarmonized Sentinel-2 MSI: MultiSpectral Instrument, Level-2A.\nRelated shp files for the Palestinian Israel area\n\n\n\n\nLand Cover Classification(Random Forest), Feature Selection(NDVI, NDBI, SAVI)\nChange detection\nMorphological Analysis, Area and Shape Filtering\nClassification(Support Vector Machine, Random Forest)\n\n\n\n\nThe main function is to provide relevant points to help users quickly locate the latest settlements or outposts. Users can select point options and a specific year to obtain the target position for that year. We also provide quantitative statistics and line charts to help users understand their changing trends.\nAdditionally, users can select other options such as West Bank borders, Palestinian-controlled areas, Israeli-controlled areas, etc. We also provide layers of some analysis processes to help users better understand the working principle of the application. Users can freely view these layers, such as SAVI analysis results, etc."
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "First, we extract satellite images from Sentinel-2 and filtering out cloud-obscured ones. These images are then subjected to machine learning analysis to identify surface features such as roads, farmland, forests, cities, and bare land. Various feature collections are imported to provide essential geographical context, including West Bank borders, Palestinian and Israeli-Palestinian control areas, and points indicating illegal appropriation.\n// Import West Bank borders.\nvar westbank = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/WestBankBorder\");\n\n// Import Palestinian control area.\nvar areaA = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaA\");\n\n// Import Israeli-Palestinian control area.\nvar areaB = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaB\");\n\nvar redpoint=ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/illegal_appropriation\")\n\n// Date range.\nvar start='2023-04-01';\nvar end='2024-04-01';\n\n// Bands.\nvar bands = ['B2','B3','B4','B5','B6','B7','B8','B8A','B11','B12'];\n  \n// Filter the Sentinel-2 collection and select the less cloudy image.\nvar sentinel  = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') \n              .filter(ee.Filter.date(start, end))\n              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n              .mean()\n              .select(bands);\n\n// Visualization of sentinel.\nvar sentinel_settings = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nMap.addLayer(sentinel.clip(AOI), sentinel_settings, 'Sentinel',false);\n\n// Visualization of westbank borders.\nvar westbank_settings = {\n  color: 'FFFFFF',\n  fillColor: '00000000',\n};\n\nMap.addLayer(westbank, westbank_settings, 'West Bank Border');\n\n// Study area.\nvar study_area = areaA.merge(areaB);\nvar study_geometry = study_area.union().geometry();\nvar buffered_geometry = study_geometry.buffer(200);\n\nMap.addLayer(buffered_geometry, {color: 'yellow'}, 'Study Area',false);\nTwo crucial functions are defined: one calculates the Soil Adjusted Vegetation Index (SAVI), and the other retrieves yearly Sentinel-2 images for analysis over time.\n// Function for calculating SAVI.\nfunction SAVI(image) {\n  // Clip area.\n  var sentinel_westbank = image.clip(westbank);\n  var sentinel_study = image.clip(buffered_geometry);\n  \n  // Calculate SAVI.\n  var savi = sentinel_westbank.expression(\n    '(NIR - RED) / (NIR + RED + 0.5) * (1 + 0.5)', {\n      'NIR': sentinel_westbank.select('B8'),\n      'RED': sentinel_westbank.select('B4')\n    }\n  ).rename('SAVI');\n\n  var barelandSAVI = savi.lt(0.2);\n  \n  return barelandSAVI;\n}\n\nfunction YearlyImages(startYear, endYear, dateSuffix, bands) {\n  // Initialize an empty dictionary to store a set of images by year.\n  var yearly_sentinel_images = ee.Dictionary();\n\n  // Loop through each year from startYear to endYear.\n  for (var year = startYear; year &lt;= endYear; year++) {\n    var start = year + dateSuffix;\n    var end = (year + 1) + dateSuffix;\n\n    var sentinel = ee.ImageCollection('COPERNICUS/S2_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n\n    yearly_sentinel_images = yearly_sentinel_images.set(year.toString(), sentinel);\n  }\n\n  return yearly_sentinel_images;\nThese yearly images are iterated over, with the SAVI function applied to each, and the resulting bare land distribution is visualized on the map, offering insights into land use changes.\n// Create yearly images.\nvar sentinel_2017_2023 = YearlyImages(2017, 2023, '-04-01', bands);\n\n// Iterate over the dictionary and apply SAVI function.\nvar savi_2017_2023 = ee.Dictionary();\nvar keys = sentinel_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var image = ee.Image(sentinel_2017_2023.get(key));\n  var savi_image = SAVI(image);\n  savi_2017_2023 = savi_2017_2023.set(key, savi_image);// savi_2015_2023 is the dictionary for Change detection.\n});\n\n// Visualization.\nvar visParams = {\n  min: 0.0,\n  max: 1.0,\n  palette: ['2a2A28', 'FF0000']\n};\n\nvar keys = savi_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var savi_image = ee.Image(savi_2017_2023.get(key));\n  Map.addLayer(savi_image, visParams, 'SAVI_' + key,false);\n});\nAdditionally, a function called calculateChange is defined, which computes differences in bare land between consecutive years, aiding in identifying new roads or settlements. This function iterates from 2017 to 2022, analyzing each yearly pair and visualizing the changes for deeper understanding.\n// Function to calculate change between two images\nfunction calculateChange(image1, image2, year1, year2) {\n  // Calculate the difference between the two images\n  var diff = image2.subtract(image1).abs(); // Taking absolute value of the difference\n  \n  // Visualize the change\n  var layerName = 'Change ' + year1 + ' to ' + year2;\n  Map.addLayer(diff, {min: 0, max: 0.5, palette: ['2A2A28', 'FF0000']}, layerName);\n}\n\n// Iterate over the years and calculate change\nfor (var i = 2017; i &lt; 2023; i++) {\n  var image1 = ee.Image(savi_2017_2023.get(i.toString()));\n  var image2 = ee.Image(savi_2017_2023.get((i + 1).toString()));\n  \n  calculateChange(image1, image2, i, i + 1);\n}\n\n\n\nThis section is specifically designed to screen, monitor, and analyze areas where the Soil Adjustment Vegetation Index (SAVI) has decreased over several consecutive years. It starts by identifying areas between adjacent years where the SAVI value has decreased, in order to determine regions of vegetation loss, especially those transitioning from above 0.2 in SAVI to below 0.2. After these changes are identified, the code applies specific filtering functions to exclude smaller patches, thereby reducing noise and errors to ensure the reliability and accuracy of the results. The filtered areas are displayed in red on the map for direct visualization and analysis. Moreover, the code vectorizes these areas and extracts centroids highlighted in yellow, which are crucial for further geospatial analysis. Ultimately, these centroids and areas are added to the map.\n//  ---------------------------Part 4: Change filter ---------------------------\n// Filter out small patches based on connected pixel size.\nfunction filterSmallPatches(image, minPixels) {\n  var connected = image.connectedPixelCount();\n  return image.updateMask(connected.gte(minPixels));\n}\n\n// Function to compare SAVI between two consecutive years, identify changes, and filter small patches.\nfunction compareAndFilterYearlySAVI(yearlyImages, startYear, endYear, minPixels) {\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filtered_change = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create a visualization layer to show these changes.\n    var changeVisualization = filtered_change.updateMask(filtered_change)\n                                             .multiply(255)\n                                             .toByte();\n    var changeParams = {\n      min: 0,\n      max: 255,\n      palette: ['000000', 'FF0000']  // Display changes in red.\n    };\n\n    Map.addLayer(changeVisualization, changeParams, 'Filtered Change to Barren ' + year + '-' + (year+1));\n  }\n}\n\n// Apply the function to compare and filter SAVI across years and visualize changes.\ncompareAndFilterYearlySAVI(savi_2017_2023, 2017, 2023, 100);\n\n\n\n// Function to compare SAVI between two consecutive years, identify changes, filter small patches, and extract centroids.\nfunction compareFilterAndExtractCentroids(yearlyImages, startYear, endYear, minPixels) {\n  var changeLayersDict = {}; // Dictionary to hold change layers\n  var centroidLayersDict = {}; // Dictionary to hold centroid layers\n\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased from above 0.2 to below 0.2.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filteredChange = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create vectors from the filtered change areas.\n    var vectors = filteredChange.reduceToVectors({\n      reducer: ee.Reducer.countEvery(),\n      geometry: study_geometry,\n      scale: 30,\n      maxPixels: 1e13\n    });\n\n    // Extract centroids of the vectors.\n    var centroids = vectors.map(function(feature) {\n      return feature.geometry().centroid();\n    });\n\n    // Add vectors and centroids to their respective dictionaries.\n    changeLayersDict[year] = filteredChange;\n    centroidLayersDict[year] = centroids;\n  }\n  return {changeLayers: changeLayersDict, centroidLayers: centroidLayersDict};\n}\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Example: Add the centroid layers for specific years to the map.\nMap.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\nMap.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\nMap.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\nMap.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\nMap.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\nMap.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n\n\nIn this part, we innovatively propose using machine learning to identify Israel building clusters.\nFirstly, let’s conduct a preliminary land screening on the West Bank of the Jordan River.\n// Pre-Processing\n\n// Calculate GLCM\nvar glcm=sentinel.toUint16().select('B8').glcmTexture({size: 4})\n\n// Calculate NDWI\nvar ndwi=sentinel.normalizedDifference(['B3','B8'])\n                  .select(['nd'],['ndwi']);\n                  \n// Calculate NDVI                 \nvar ndvi=sentinel.normalizedDifference(['B8','B4'])\n                  .select(['nd'],['ndvi']);\n\n// Calculate NDBI                 \nvar ndbi=sentinel.normalizedDifference(['B11','B8'])\n                  .select(['nd'],['ndbi']);\n                  \n// Clip the map\nvar westbankborder = sentinel.clip(westbank);\n\n// Update the mask\nvar westbank_image= westbankborder\n                  .updateMask(ndwi.lt(0.3))\n                  .updateMask(ndvi.lt(0.2))\n                  .updateMask(ndbi.gt(0.1))\n                  .addBands(glcm)\n                  .addBands(ndbi)\n                  .select(bands);\n                  \n// Display the results\nMap.centerObject(westbank, 8);  // Center the map on the certain area with an appropriate zoom level\nMap.addLayer(westbank_image, {bands: ['B4', 'B3', 'B2'], max: 2000}, 'westbankborder');\nThen, we manually annotated Israeli and Palestinian building clusters. During this process, we made an unexpected discovery that the newly developed lands were developed by Israel, and due to resource constraints, it would be impossible for Palestine to engage in new land excavation. To enhance precision, we also marked desert areas due to the difficulty in distinguishing them from buildings using the NDVI and NDBI.\nTherfore, we divided three classes: Class 1: is Israel building clusters Class 2: is Palestinian building clusters Class3: is the desert areas\n// Generating Labeled Data\n\n// Take random samples of points from within these polygons\n\n// Take points in each polygon\nvar points_in_Israeli = mergedAreas1235.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 250)\n  .map(function(point) {\n    return point.set({'class': 0});\n });\n}).flatten();\n\nvar points_outside_Israeli = Outside_Israeli.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 400)\n  .map(function(point) {\n    return point.set({'class': 1});\n });\n}).flatten();\n\nvar desert_points = Desert_Areas.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 1080)\n  .map(function(point) {\n    return point.set({'class': 2});\n  });\n}).flatten();\n\n// Create one feature collection\nvar Israeli_points = ee.FeatureCollection([points_in_Israeli,\n                                  points_outside_Israeli,\n                                  desert_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();    \n                                  \n// Create a sample dataset from the merged marked area\nvar split=0.7\nvar training_samples = Israeli_points.filter(ee.Filter.lt('random', split));\nvar validation_sample = Israeli_points.filter(ee.Filter.gte('random', split));\n\n// Obtain training set\nvar training = westbank_image.sampleRegions({\n  collection: training_samples,\n  properties: ['class'],\n  scale: 10,\n});\n\n// Obtain validation set\nvar validation = westbank_image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// Select classification features and training classifiers\nvar model = ee.Classifier.smileRandomForest(500)\n                         .train(training, 'class');\n\nprint('Training class 0:', training_samples.filter(ee.Filter.eq('class', 0)).size());\nprint('Training class 1:', training_samples.filter(ee.Filter.eq('class', 1)).size());\nprint('Training class 2:', training_samples.filter(ee.Filter.eq('class', 2)).size());\nprint('Validation class 0:', validation_sample.filter(ee.Filter.eq('class', 0)).size());\nprint('Validation class 1:', validation_sample.filter(ee.Filter.eq('class', 1)).size());\nprint('Validation class 2:', validation_sample.filter(ee.Filter.eq('class', 2)).size());\n\n// Make prediction\nvar prediction = westbank_image.classify(model);\n\n// Select Israeli architectural complex\nvar Israeli_prediction=prediction.updateMask(prediction.eq(0));\n\n// Add layer\nMap.addLayer(Israeli_prediction, {palette:'red'}, 'Predicted Israeli Architectural Complex');\n\n// Validate the model with the validation dataset and classify the samples\nvar validated = validation.classify(model);\n\n// Compute the error matrix for the validation results to assess the accuracy\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\n// Print the confusion matrix to the console for evaluation\nprint('Confusion Matrix ', testAccuracy);\nThe model’s accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.\nAll in all, the model shows potential in identifying Israeli building clusters. By combining historical Israel’s exploitation of vacant land and identifying Israel based on historical data, illegal encroachments can be identified.\n\n\n\nThis code segment primarily establishes and configures a user interface (UI) panel for interactively displaying and managing map layers. The panel allows users to select from various map layers such as “West Bank Border,” “SAVI” (Soil Adjusted Vegetation Index), “Change Detection,” and “Predicted Israeli Architectural Complex” through a dropdown menu. The interface updates the displayed map layers and associated information based on the user’s selection.\nAdditionally, the panel includes a slider for selecting years, which influences the displayed content of map layers, such as SAVI indices or change detection results. Moreover, the panel supports the display of additional control elements like information buttons and year labels, which are displayed conditionally depending on the currently selected map layer.\nThere’s also an information panel used to display more detailed descriptions or data, such as error matrices. These controls are dynamically managed through written functions, such as showing and hiding specific controls, updating map layers, or handling map click events, thereby enhancing user interaction.\n \n// ---------------------------Part 5: create UI Panel---------------------------\nvar panel = ui.Panel();\npanel.style().set({\n  width: '400px',\n  padding: '8px'\n});\nui.root.insert(0, panel);\n\n// Layer select change event handler\nvar layerSelect = ui.Select({\n  items: ['West Bank Border', 'SAVI', 'Change detection', 'Predicted Israeli Architectural Complex','Barren Centers','Built-Up Centers'],\n  onChange: handleLayerChange\n});\n\n// Function to handle layer changes\nfunction handleLayerChange(selected) {\n  currentLayer = selected;\n  var showSlider = selected === 'SAVI' || selected === 'Change detection' || selected === 'Built-Up Centers' || selected === 'Barren Centers';\n  var showChart = selected === 'SAVI'; // Only show chart for SAVI layer\n  var showLabels = selected === 'SAVI' || selected === 'Change detection' || selected === 'Built-Up Centers' || selected === 'Barren Centers';\n  var showInfoButton = selected === 'Predicted Israeli Architectural Complex';\n\n  // Update the visibility of UI components\n  //toggleInfoButton.style().set('shown', showInfoButton);\n  updateLabelPanelVisibility(showLabels);\n  yearSlider.style().set('shown', showSlider);\n  yearLabel.style().set('shown', showSlider);\n  \n  // Reset and update map layers\n  Map.layers().reset();\n  updateMapLayers(selected);\n\n  // Update the display of charts\n  if (showChart) {\n    updateChart(yearSlider.getValue());\n  } else {\n    clearChart();\n  }\n\n  // Display the confusion matrix if required\n  if (selected === 'Predicted Israeli Architectural Complex'){\n      var errorMatrix = validated.errorMatrix('class', 'classification');\n      displayConfusionMatrix(errorMatrix);\n  }\n  \n  if (selected === 'Change detection'){\n    \n    var description = ui.Label('We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.');\n    panel.add(description);  // Add the description\n    currentWidgets.push(description);\n  \n  }\n  if (selected === 'SAVI'){\n    \n    var savidescription = ui.Label('Through SAVI, we can find all the bare land stocks in the corresponding year. Zooming in on the image we can see plots of different sizes and shapes. After excluding fragmented farmland and huge areas of desert, the large-scale plots are likely to be new construction sites.');\n    panel.add(savidescription);  // Add the description\n    currentWidgets.push(savidescription);\n    panel.add(toggleRegionButton);  // Add the description\n    currentWidgets.push(toggleRegionButton);\n  \n  }\n}\n\n// Add controls to the panel\npanel.add(ui.Label('Layer Selector:', {fontWeight: 'bold'}));\npanel.add(layerSelect);\n\nvar currentWidgets = [];  // Array to store current widgets for easy removal\n\n// Create a slider to select the year\nvar yearSlider = ui.Slider({\n  min: 2017,\n  max: 2023,\n  value: 2017,\n  step: 1,\n  style: {stretch: 'horizontal', shown: false}\n});\nvar yearLabel = ui.Label('Current Year:', {fontWeight: 'bold', shown: false});\npanel.add(yearLabel);\npanel.add(yearSlider);\n\n// Create year labels\nvar yearLabels = {\n  '2017': '2017',\n  '2018': '2018',\n  '2019': '2019',\n  '2020': '2020',\n  '2021': '2021',\n  '2022': '2022',\n  '2023': '2023'\n};\n\n// Create a panel for year labels, initially not shown\nvar labelPanel = ui.Panel({\n  widgets: Object.keys(yearLabels).map(function(year) {\n    return ui.Label(yearLabels[year], {shown: false});\n  }),\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', textAlign: 'justify-between', shown: false}\n});\npanel.add(labelPanel);\n\n// Create an info panel\nvar infoPanel = ui.Panel({\n  style: {\n    position: 'bottom-left',\n    width: '300px',\n    maxHeight: '400px',\n    padding: '8px',\n    backgroundColor: 'white',\n    shown: false\n  }\n});\n\n// Create a button to toggle the display of information\nvar toggleInfoButton = ui.Button({\n  label: 'Show/Hide Information',\n  onClick: function() {\n    var shown = infoPanel.style().get('shown');\n    infoPanel.style().set('shown', !shown);\n  },\n  style: {\n    shown: false\n  }\n});\npanel.add(toggleInfoButton);\n\n// Function to update the visibility of the label panel\nfunction updateLabelPanelVisibility(visible) {\n  labelPanel.widgets().forEach(function(label) {\n    label.style().set('shown', visible);\n  });\n  labelPanel.style().set('shown', visible);\n}\n\n// Global variable to keep track of the current selected layer\nvar currentLayer = '';\n\nvar saviregion\n// Start with study_area as the default active region\nvar activeGeometry = study_area;\n// Button to toggle between study_area and saviregion\nvar toggleRegionButton = ui.Button('Toggle Geometry');  // Initial label setup\n\ntoggleRegionButton.onClick(function() {\n  // Toggle the active geometry\n  activeGeometry = (activeGeometry === study_area) ? saviregion : study_area;\n  \n  // Update the label of the button\n  var newLabel = 'Active Geometry: ' + (activeGeometry === study_area ? 'Study Area' : 'SAVI Region');\n  toggleRegionButton.setLabel(newLabel);\n\n  // Recalculate counts when the geometry is toggled\n  //calculateSAVI1Counts();\n});\n\n// Global variable to store the reference of the clicked point layer\nvar clickedPointLayer = null;\n\nfunction mapClickHandler(coords) {\n  var point = ee.Geometry.Point([coords.lon, coords.lat]);\n\n  // Adjust this buffer radius as needed or use it directly for point-based analysis\n  saviregion = point.buffer(1000);  // 1000 meter buffer around the clicked point\n\n  // Clear previous clicked point from the map (optional)\n  if (clickedPointLayer !== null) {\n    Map.layers().remove(clickedPointLayer);\n  }\n\n  // Define the style for the point\n  var pointStyle = {color: 'green', fillColor: '00000000'};\n\n  // Add the point to the map with style\n  clickedPointLayer = Map.addLayer(point, pointStyle, 'Clicked Point');\n\n  // Additional actions based on current layer type\n  if (currentLayer === 'SAVI') {\n    var saviImage = ee.Image(savi_2017_2023.get(yearSlider.getValue().toString()));\n    // Further processing or layer addition can be handled here\n  }\n}\n\n// Register map click event\nMap.onClick(mapClickHandler);\n\nfunction resetYearselector() {\n      panel.remove(yearLabel);\n      panel.remove(yearSlider);\n      panel.add(yearLabel);\n      panel.add(yearSlider);\n}\n\n// Function used to update the map display based on the selected layer\nfunction updateMapLayers(selected) {\n  Map.layers().reset();\n  Map.setOptions(\"satellite\");\n  var darkLayer = ee.Image.constant(0).visualize({palette: ['000000'], opacity: 0.5}); \n  Map.addLayer(darkLayer, {}, 'Dark Layer');\n  Map.setZoom(13);\n  removeChart();\n  var year = yearSlider.getValue();\n  // Clear specific widgets related to the confusion matrix\n        currentWidgets.forEach(function(widget) {\n            panel.remove(widget);\n        });\n        currentWidgets = [];  // Reset the widget tracker\n  switch (selected) {\n    case 'West Bank Border':\n      Map.addLayer(westbank, westbank_settings, 'West Bank Border');\n      break;\n    case 'SAVI':\n      //clearChart();\n      resetYearselector();\n      var savi_image = ee.Image(savi_2017_2023.get(yearSlider.getValue().toString()));\n      Map.addLayer(savi_image, visParams, 'SAVI_' + yearSlider.getValue().toString());\n      break;\n    case 'Change detection':\n      //clearChart();\n      var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n      currentWidgets.push(description);\n      resetYearselector();\n      if (year &gt; 2017) {\n        var image1 = ee.Image(savi_2017_2023.get((year - 1).toString()));\n        var image2 = ee.Image(savi_2017_2023.get(year.toString()));\n        calculateChange(image1, image2, year - 1, year);\n      }\n      break;\n    case 'Predicted Israeli Architectural Complex':\n      Map.addLayer(Israeli_prediction, {palette: 'red'}, 'Predicted Israeli Architectural Complex',true);\n      break;\n    case 'Built-Up Centers':\n      //clearChart();\n      var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n      currentWidgets.push(description);\n      resetYearselector();\n      //classifyAndVisualizeCenters(savi_2017_2023, year, year + 1, 100);\n      // Example: Add the centroid layers for specific years to the map.\n     Map.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\n     Map.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\n     Map.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\n     Map.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\n     Map.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\n     Map.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n\n\n      break;\n    case 'Barren Centers':\n      //clearChart();\n      var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n      currentWidgets.push(description);\n      resetYearselector();\n      Map.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\n      Map.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\n      Map.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\n      Map.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\n      Map.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\n      Map.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n      //classifyAndVisualizeCenters(savi_2017_2023, year, year + 1, 100);\n      break;\n  }\n\n}\n\nui.root.add(infoPanel);\nvar errorMatrix = validated.errorMatrix('class', 'classification');\n\n// Default display of the initial year's layer\nupdateMapLayers('SAVI');\nlayerSelect.setValue('SAVI', true);\n\n// Function to update or clear chart based on current layer\n// Calculate the number of pixels with SAVI=1 for each year from 2017 to 2023 and add a line chart to the existing panel\n\nvar savedChart;\nfunction calculateSAVI1Counts() {\n  var counts = []; // Array to store counts for each year\n\n  // Iterate through each year\n  for (var year = 2017; year &lt;= 2023; year++) {\n    var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n\n    // Create a mask for SAVI values equal to 1\n    var mask1 = selectedYearImage.eq(1);\n\n    // Apply the mask\n    var image1 = selectedYearImage.updateMask(mask1);\n\n    // Calculate the number of pixels with SAVI value equal to 1\n    var countPixels1 = image1.reduceRegion({\n      reducer: ee.Reducer.count(),\n      geometry: activeGeometry,\n      scale: 30,\n      maxPixels: 1e9\n    });\n\n    // Add each year's result to the array\n    counts.push({\n      'year': year,\n      'count': countPixels1.get('SAVI')\n    });\n  }\n\n  // Convert the results array to a FeatureCollection\n  var countFeatures = ee.FeatureCollection(counts.map(function(item) {\n    return ee.Feature(null, item);\n  }));\n\n  // Create a line chart\n  var countChart = ui.Chart.feature.byFeature({\n    features: countFeatures,\n    xProperty: 'year',\n    yProperties: ['count']\n  })\n  .setOptions({\n    title: 'SAVI = 1 Pixel Counts from 2017 to 2023',\n    hAxis: {title: 'Year'},\n    vAxis: {title: 'Count of Pixels'},\n    lineWidth: 1,\n    pointSize: 3\n  });\n\n  // Add the chart to the existing panel\n  panel.widgets().add(countChart);\n  savedChart = countChart;\n}\n\n// Function to remove the chart\nfunction removeChart() {\n  if (savedChart) {\n    panel.widgets().remove(savedChart);\n    savedChart = null; // Clear the reference, indicating that there is currently no chart\n  }\n}\n\nfunction updateChart(year) {\n  var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n\n  // Create masks for SAVI values 0 and 1\n  var mask0 = selectedYearImage.eq(0);\n  var mask1 = selectedYearImage.eq(1);\n\n  // Apply masks to the original image\n  var image0 = selectedYearImage.updateMask(mask0);\n  var image1 = selectedYearImage.updateMask(mask1);\n\n  // Generating a histogram for SAVI values\n  var histogramChart = ui.Chart.image.histogram({\n    image: ee.Image.cat([image0.select('SAVI'), image1.select('SAVI')]),\n    region: activeGeometry,\n    scale: 30,\n    minBucketWidth: 0.001,  // Each bucket corresponds exactly to one SAVI value\n  }).setOptions({\n    title: year + ' SAVI Value Distribution',\n    vAxis: {title: 'Pixel Count'},\n    hAxis: {title: 'SAVI', ticks: [{v:0, f:'0'}, {v:1, f:'1'}]}, // Explicitly show only 0 and 1\n    series: {\n      0: {color: 'blue', label: 'SAVI = 0'},  // Color and label for SAVI value 0\n      1: {color: 'red', label: 'SAVI = 1'}    // Color and label for SAVI value 1\n    },\n    bar: {groupWidth: \"20%\"}  // Adjust the width of the bars\n  });\n\n  // Count and print the number of pixels with SAVI = 1\n  var countPixels1 = image1.reduceRegion({\n    reducer: ee.Reducer.count(),\n    geometry: activeGeometry,\n    scale: 30,\n    maxPixels: 1e9\n  });\n\n  // Check if there is already a chart at the expected position in the panel and replace it or add the new chart.\n  if (panel.widgets().length() &gt; 2) {\n    panel.widgets().set(2, histogramChart); // Replace the existing chart\n  } else {\n    panel.widgets().insert(2, histogramChart); // Add the chart if not already present\n  }\n  //panel.widgets().remove(countChart);\n  calculateSAVI1Counts();\n}\n\n// Function to clear the chart\nfunction clearChart() {\n  if (panel.widgets().length() &gt; 2) {\n    panel.remove(panel.widgets().get(2));  // Remove the chart widget\n  }\n}\n\n// Slider event handling\nyearSlider.onSlide(function(value) {\n  yearLabel.setValue('Current Year: ' + value);\n\n  // Updates the current layer, which may affect charts, map layers, and descriptions\n  updateMapLayers(currentLayer);\n\n  // If the current layer requires a specific description, it is handled here\n  if (currentLayer === 'SAVI') {\n    updateChart(value); // Update chart only if SAVI is currently selected\n    updateDescriptionForSAVI();\n  } else if (currentLayer === 'Change detection') {\n    updateDescriptionForChangeDetection();\n  } else if (currentLayer === 'Predicted Israeli Architectural Complex') {\n    updateDescriptionForPredictedIsraeliArchitecturalComplex();\n  } else if (currentLayer === 'Built-Up Centers' || currentLayer === 'Barren Centers') {\n    updateDescriptionForCenters();\n  }\n});\n\n// Helper functions to manage descriptions for different layers\nfunction updateDescriptionForSAVI() {\n  clearDescriptions();\n  var description = ui.Label('Through SAVI, we can find all the bare land stocks in the corresponding year. Zooming in on the image we can see plots of different sizes and shapes. After excluding fragmented farmland and huge areas of desert, the large-scale plots are likely to be new construction sites.');\n  panel.add(description);\n  // Add the button to the UI Panel\n  panel.add(toggleRegionButton);\n  currentWidgets.push(description,toggleRegionButton);\n}\n\nfunction updateDescriptionForChangeDetection() {\n  clearDescriptions();\n  var description = ui.Label('We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.');\n  panel.add(description);\n  currentWidgets.push(description);\n}\n\nfunction updateDescriptionForPredictedIsraeliArchitecturalComplex() {\n  clearDescriptions();\n  var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n  panel.add(description);\n  currentWidgets.push(description);\n}\n\nfunction updateDescriptionForCenters() {\n  clearDescriptions();\n  var description = ui.Label('Through this view, we can analyze the urban development over the years.');\n  panel.add(description);\n  currentWidgets.push(description);\n}\n\n// Function to clear previously added descriptions\nfunction clearDescriptions() {\n  currentWidgets.forEach(function(widget) {\n    panel.remove(widget);\n  });\n  currentWidgets = [];  // Reset the widget tracker\n}\n\n// Function to display confusion matrix\nfunction displayConfusionMatrix(errorMatrix) {\n  // Clear previously added widgets from the panel\n  currentWidgets.forEach(function(widget) {\n        panel.remove(widget);\n    });\n  currentWidgets = [];  // Reset the array after clearing\n  var matrixArray = errorMatrix.array();\n  var matrixChart = ui.Chart.array.values({\n    array: matrixArray,\n    axis: 0,\n    xLabels: errorMatrix.order()\n  }).setChartType('Table').setOptions({\n    title: 'Confusion Matrix',\n    hAxis: {title: 'Predicted Label'},\n    vAxis: {title: 'Actual Label'},\n    colors: ['yellow', 'red', 'green']\n  });\n\n  // Add chart description\n  var description = ui.Label('The red dots identified are the projected building complexes in Israel.');\n  //panel.clear();  // Clear previous elements in the panel\n  panel.add(description);  // Add the description\n  panel.add(matrixChart);  // Display the chart\n  currentWidgets.push(description, matrixChart);  // Store references to remove later\n}"
  }
]