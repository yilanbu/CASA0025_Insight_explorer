[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "New Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "Israeli expansion of new settlements and Palestinian villages\n\n\n\n\nThe hot war in Gaza is well known in the Israeli-Palestinian conflict, but the slow erosion of the West Bank has received little attention.\nIn the West Bank of the Jordan River, Israel continues to encroach on Palestinian land by establishing illegal outposts, transforming them into settlements, and eventually legalizing them. The purpose of this application is to detect these new settlements.\nMany journalists hope to mitigate the situation of Palestinian victimization through early intervention and raise public awareness about the status of Palestine beyond Gaza. However, sometimes they manually search for these targets on Google earth. We hope to help them quickly locate these targets through this application.\n\n\nThe purpose of this application is to use satellite imagery to find and mark new Israeli settlements in the West Bank. The target has certain characteristics. Finding a series of methods to filter and mark them with the features is the main problem the application needs to solve.\nFor target users, the application should also provide a user interface in which they can quickly query the location and number of these newly emerged territorial encroachments.\nThrough this application, we hope that it can make a small contribution to arousing a more comprehensive public understanding of the Palestinian-Israeli conflict.\n\n\n\n\nJournalists, researchers and international organizations\n\nMany newly Israeli settlements are illegal. Usually when settlements develop to a certain scale, Israel will declare them legal. Early detection can help the international community intervene earlier. Some reporters did a manual blanket search through Google Earth. We hope this helps them resolve the issue quickly.\n\nPublic\n\nThe public can also use the app to understand how Israel has invaded Palestinian land, ultimately leading to the pockmarked borders of the area’s controlled areas.\nThis news article provides a detailed look at the Israeli-occupied territories.\n\n\n\n\n\n\nHarmonized Sentinel-2 MSI: MultiSpectral Instrument, Level-2A. (Surface Reflectance)\nThe resolution is 10m.\nThe time span is 2017-03-28 – Present.\n\nAlthough our main purpose is to detect only the latest Israeli settlements, to use machine learning to distinguish settlement ownership, the larger the data set, the better. Therefore, we use all available years for identification and training. To make full use of the data, we cut the data by year with 04-01 as the boundary, and then preprocessed the data of each year. For example, the data in 2023 corresponds to 2023-04-01 - 2024-04-01.\n\n\n\nRelated shapefiles of Westbank area.\n\n\n\n\nThis application initially uses the SAVI to identify target land types, then employs change detection to identify newly cultivated land plots that appear each year. These plots include changes in desert areas and minor agricultural land developments. Therefore, it is necessary to use shape and area filtering to select plots of specific areas and shapes, and subsequently pinpoint their central locations. Finally, we attempt to distinguish whether these plots belong to Israel through machine learning.\n\nFeature Selection(NDVI, SAVI), Land Cover Classification(Random Forest)\nChange detection(difference, T-test)\nMorphological Analysis, Area and Shape Filtering\nClassification(Support Vector Machine, Random Forest)\n\n\n\n\nWork Flow\n\n\n\n\n\nThe main function is to provide target points to help users quickly locate the latest settlements or outposts. The left side is the operation panel. Users can select “New Israeli Settlement Locations” button and a specific year to obtain the target position for that year. We also provide quantitative statistics and line charts to help users understand their changing trends.\nAdditionally, users can select other options such as “West Bank Border”, “Control Areas”, “SAVI”, etc. We also provide layers of some background and analysis processes to help users better understand the working principle of the application. Users can freely view these layers, and look for image features that interest them.\n\n\n\n\n\n\n\n\n\n\n\n// The workflow of this application is clearly step-by-step, making it possible to distribute tasks evenly and reasonably. \n\n// The entire application development is divided into five parts, and each member is responsible for one part.\n\n// In the exploration process, some of the ineffective methods were not reflected in the final application. In order to reflect the contribution of each member, the comments in subsequent code blocks will describe what the members are responsible for and what is not reflected.\n\n// Manual annotation for machine learning is completed by the group.\n\n\nFirst, we extract satellite images from Sentinel-2 and filtering out cloud-obscured ones. These images are then subjected to machine learning analysis to identify surface features such as roads, farmland, forests, cities, and bare land. Various feature collections are imported to provide essential geographical context, including West Bank borders, Palestinian and Israeli-Palestinian control areas, and points indicating illegal appropriation.\n// ---------------------------------------------------------------------------------\n// Beginning of part1\n// Developed by Mingyu Bi \n// Unreflected workload includes attempts to classify land based on RF\n// ---------------------------------------------------------------------------------\n\n\n\n// Import West Bank borders.\nvar westbank = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/WestBankBorder\");\n\n// Import Palestinian control area.\nvar areaA = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaA\");\n\n// Import Israeli-Palestinian control area.\nvar areaB = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaB\");\n\nvar redpoint=ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/illegal_appropriation\")\n\n// Date range.\nvar start='2023-04-01';\nvar end='2024-04-01';\n\n// Bands.\nvar bands = ['B2','B3','B4','B5','B6','B7','B8','B8A','B11','B12'];\n  \n// Filter the Sentinel-2 collection and select the less cloudy image.\nvar sentinel  = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') \n              .filter(ee.Filter.date(start, end))\n              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n              .mean()\n              .select(bands);\n\n// Visualization of sentinel.\nvar sentinel_settings = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nMap.addLayer(sentinel.clip(AOI), sentinel_settings, 'Sentinel',false);\n\n// Visualization of westbank borders.\nvar westbank_settings = {\n  color: 'FFFFFF',\n  fillColor: '00000000',\n};\n\nMap.addLayer(westbank, westbank_settings, 'West Bank Border');\n\n// Study area.\nvar study_area = areaA.merge(areaB);\nvar study_geometry = study_area.union().geometry();\nvar buffered_geometry = study_geometry.buffer(200);\n\nMap.addLayer(buffered_geometry, {color: 'yellow'}, 'Study Area',false);\nFor the purpose of machine learning training in part 4, we need to increase the amount of data, so two functions are defined: one calculates SAVI, and the other retrieves yearly Sentinel-2 images for analysis over time.\n// ---------------------------Create functions.---------------------------\n\n// Function for calculating SAVI.\nfunction SAVI(image) {\n  // Clip area.\n  var sentinel_westbank = image.clip(westbank);\n  var sentinel_study = image.clip(buffered_geometry);\n  \n  // Calculate SAVI.\n  var savi = sentinel_westbank.expression(\n    '(NIR - RED) / (NIR + RED + 0.5) * (1 + 0.5)', {\n      'NIR': sentinel_westbank.select('B8'),\n      'RED': sentinel_westbank.select('B4')\n    }\n  ).rename('SAVI');\n\n  var barelandSAVI = savi.lt(0.2);\n  \n  return barelandSAVI;\n}\n\nfunction YearlyImages(startYear, endYear, dateSuffix, bands) {\n  // Initialize an empty dictionary to store a set of images by year.\n  var yearly_sentinel_images = ee.Dictionary();\n\n  // Loop through each year from startYear to endYear.\n  for (var year = startYear; year &lt;= endYear; year++) {\n    var start = year + dateSuffix;\n    var end = (year + 1) + dateSuffix;\n\n    var sentinel = ee.ImageCollection('COPERNICUS/S2_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n\n    yearly_sentinel_images = yearly_sentinel_images.set(year.toString(), sentinel);\n  }\n\n  return yearly_sentinel_images;\n}\nApply the function to obtain year-by-year images and calculate SAVI. The results are organized into a dictionary for easy call in the next step.\n// ---------------------------Apply the function.---------------------------\n\n// Create yearly images.\nvar sentinel_2017_2023 = YearlyImages(2017, 2023, '-04-01', bands);\n\n// Iterate over the dictionary and apply SAVI function.\nvar savi_2017_2023 = ee.Dictionary();\nvar keys = sentinel_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var image = ee.Image(sentinel_2017_2023.get(key));\n  var savi_image = SAVI(image);\n  savi_2017_2023 = savi_2017_2023.set(key, savi_image); // savi_2017_2023 is the dictionary for Change detection.\n});\n\n// Visualization.\nvar visParams = {\n  min: 0.0,\n  max: 1.0,\n  palette: ['2a2A28', 'FF0000']\n};\n\nvar keys = savi_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var savi_image = ee.Image(savi_2017_2023.get(key));\n  Map.addLayer(savi_image, visParams, 'SAVI_' + key,false);\n});\n\n// ---------------------------------------------------------------------------------\n// End of part1\n// ---------------------------------------------------------------------------------\n\n\n\nThen, a function called calculateChange is defined, which computes differences in bare land between consecutive years, aiding in identifying new roads or settlements. This function iterates from 2017 to 2023, analyzing each yearly pair and visualizing the changes for deeper understanding.\nThe SAVI analysis result obtained in the previous step is a binary image, so among various methods, direct difference can obtain the best result.\n// ---------------------------------------------------------------------------------\n// Beginning of part2\n// Developed by Xiaolin Liu\n// Unreflected workload includes T-test on different satellite images sets or analysis results\n// ---------------------------------------------------------------------------------\n\n\n\n// Function to calculate change between two images\nfunction calculateChange(image1, image2, year1, year2) {\n  // Calculate the difference between the two images\n  var diff = image2.subtract(image1).abs(); // Taking absolute value of the difference\n  \n  // Visualize the change\n  var layerName = 'Change ' + year1 + ' to ' + year2;\n  Map.addLayer(diff, {min: 0, max: 0.5, palette: ['2A2A28', 'FF0000']}, layerName);\n}\n\n// Iterate over the years and calculate change\nfor (var i = 2017; i &lt; 2023; i++) {\n  var image1 = ee.Image(savi_2017_2023.get(i.toString()));\n  var image2 = ee.Image(savi_2017_2023.get((i + 1).toString()));\n  \n  calculateChange(image1, image2, i, i + 1);\n}\n\n// ---------------------------------------------------------------------------------\n// End of part2\n// ---------------------------------------------------------------------------------\n\n\n\nIn part 2, subtraction will capture the appearance and disappearance of bare land at the same time. Therefore, this section is specifically designed to screen, monitor, and analyze areas where the Soil Adjustment Vegetation Index (SAVI) has decreased over several consecutive years. It starts by identifying areas between adjacent years where the SAVI value has decreased, in order to determine regions of vegetation loss, especially those transitioning from above 0.2 in SAVI to below 0.2.\nAfter these changes are identified, the code applies specific filtering functions to exclude smaller patches, thereby reducing noise and errors to ensure the reliability and accuracy of the results. The filtered areas are displayed in red on the map for direct visualization and analysis. Moreover, the code vectorizes these areas and extracts centroids highlighted in yellow, which are crucial for further geospatial analysis. Ultimately, these centroids and areas are added to the map.\n// ---------------------------------------------------------------------------------\n// Beginning of part3\n// Developed by Xinyu Guo, Yilan Bu \n// Yilan Bu: Optimized the change detection step so that the acquired image is one-way (bare ground appears) and filter\n// Xinyu Guo: Filter and extract the center point of the target geometry\n// ---------------------------------------------------------------------------------\n\n\n\n// Filter out small patches based on connected pixel size.\nfunction filterSmallPatches(image, minPixels) {\n  var connected = image.connectedPixelCount();\n  return image.updateMask(connected.gte(minPixels));\n}\n\n// Function to compare SAVI between two consecutive years, identify changes, and filter small patches.\nfunction compareAndFilterYearlySAVI(yearlyImages, startYear, endYear, minPixels) {\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filtered_change = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create a visualization layer to show these changes.\n    var changeVisualization = filtered_change.updateMask(filtered_change)\n                                             .multiply(255)\n                                             .toByte();\n    var changeParams = {\n      min: 0,\n      max: 255,\n      palette: ['000000', 'FF0000']  // Display changes in red.\n    };\n\n    Map.addLayer(changeVisualization, changeParams, 'Filtered Change to Barren ' + year + '-' + (year+1));\n  }\n}\n\n// Apply the function to compare and filter SAVI across years and visualize changes.\ncompareAndFilterYearlySAVI(savi_2017_2023, 2017, 2023, 100);\n\n// Function to compare SAVI between two consecutive years, identify changes, filter small patches, and extract centroids.\nfunction compareFilterAndExtractCentroids(yearlyImages, startYear, endYear, minPixels) {\n  var changeLayersDict = {}; // Dictionary to hold change layers\n  var centroidLayersDict = {}; // Dictionary to hold centroid layers\n\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased from above 0.2 to below 0.2.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filteredChange = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create vectors from the filtered change areas.\n    var vectors = filteredChange.reduceToVectors({\n      reducer: ee.Reducer.countEvery(),\n      geometry: study_geometry,\n      scale: 30,\n      maxPixels: 1e13\n    });\n\n    // Extract centroids of the vectors.\n    var centroids = vectors.map(function(feature) {\n      return feature.geometry().centroid();\n    });\n\n    // Add vectors and centroids to their respective dictionaries.\n    changeLayersDict[year] = filteredChange;\n    centroidLayersDict[year] = centroids;\n  }\n  return {changeLayers: changeLayersDict, centroidLayers: centroidLayersDict};\n}\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Example: Add the centroid layers for specific years to the map.\nMap.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\nMap.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\nMap.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\nMap.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\nMap.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\nMap.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n// ---------------------------------------------------------------------------------\n// End of part3\n// ---------------------------------------------------------------------------------\n\n\n\nIn part 3 we get a series of target points, but some desert variations and possibly Palestinian land will also be included. And it’s hard to tell who exactly the bare land belongs to. Therefore we try to capture features that are imperceptible to the human eye through machine learning.\nPalestinian-Israeli architectural complexes vary greatly. The current complex corresponds to bare land on historical satellite images. We attempted to guide the classification of bare land by classifying building groups.\n// ---------------------------------------------------------------------------------\n// Beginning of part4\n// Developed by Yilan Bu \n// Unreflected workload includes attempts at various classification orders and methods\n// ---------------------------------------------------------------------------------\n\n\n\n// Pre-Processing\n\n// Calculate GLCM\nvar glcm=sentinel.toUint16().select('B8').glcmTexture({size: 4})\n\n// Calculate NDWI\nvar ndwi=sentinel.normalizedDifference(['B3','B8'])\n                  .select(['nd'],['ndwi']);\n                  \n// Calculate NDVI                 \nvar ndvi=sentinel.normalizedDifference(['B8','B4'])\n                  .select(['nd'],['ndvi']);\n\n// Calculate NDBI                 \nvar ndbi=sentinel.normalizedDifference(['B11','B8'])\n                  .select(['nd'],['ndbi']);\n                  \n// Clip the map\nvar westbankborder = sentinel.clip(westbank);\n\n// Update the mask\nvar westbank_image= westbankborder\n                  .updateMask(ndwi.lt(0.3))\n                  .updateMask(ndvi.lt(0.2))\n                  .updateMask(ndbi.gt(0.1))\n                  .addBands(glcm)\n                  .addBands(ndbi)\n                  .select(bands);\n                  \n// Display the results\nMap.centerObject(westbank, 8);  // Center the map on the certain area with an appropriate zoom level\nMap.addLayer(westbank_image, {bands: ['B4', 'B3', 'B2'], max: 2000}, 'westbankborder');\nThen, we manually annotated Israeli and Palestinian building clusters. To enhance precision, we also marked desert areas due to the difficulty in distinguishing them from buildings using the NDVI and NDBI.\nTherfore, we divided three classes:\n\nClass 1: Israel building clusters\nClass 2: Palestinian building clusters\nClass3: Desert areas\n\n// Generating Labeled Data\n\n// Take random samples of points from within these polygons\n\n// Take points in each polygon\nvar points_in_Israeli = mergedAreas1235.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 250)\n  .map(function(point) {\n    return point.set({'class': 0});\n });\n}).flatten();\n\nvar points_outside_Israeli = Outside_Israeli.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 400)\n  .map(function(point) {\n    return point.set({'class': 1});\n });\n}).flatten();\n\nvar desert_points = Desert_Areas.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 1080)\n  .map(function(point) {\n    return point.set({'class': 2});\n  });\n}).flatten();\n\n// Create one feature collection\nvar Israeli_points = ee.FeatureCollection([points_in_Israeli,\n                                  points_outside_Israeli,\n                                  desert_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();    \n                                  \n// Create a sample dataset from the merged marked area\nvar split=0.7\nvar training_samples = Israeli_points.filter(ee.Filter.lt('random', split));\nvar validation_sample = Israeli_points.filter(ee.Filter.gte('random', split));\n\n// Obtain training set\nvar training = westbank_image.sampleRegions({\n  collection: training_samples,\n  properties: ['class'],\n  scale: 10,\n});\n\n// Obtain validation set\nvar validation = westbank_image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// Select classification features and training classifiers\nvar model = ee.Classifier.smileRandomForest(500)\n                         .train(training, 'class');\n\nprint('Training class 0:', training_samples.filter(ee.Filter.eq('class', 0)).size());\nprint('Training class 1:', training_samples.filter(ee.Filter.eq('class', 1)).size());\nprint('Training class 2:', training_samples.filter(ee.Filter.eq('class', 2)).size());\nprint('Validation class 0:', validation_sample.filter(ee.Filter.eq('class', 0)).size());\nprint('Validation class 1:', validation_sample.filter(ee.Filter.eq('class', 1)).size());\nprint('Validation class 2:', validation_sample.filter(ee.Filter.eq('class', 2)).size());\n\n// Make prediction\nvar prediction = westbank_image.classify(model);\n\n// Select Israeli architectural complex\nvar Israeli_prediction=prediction.updateMask(prediction.eq(0));\n\n// Add layer\nMap.addLayer(Israeli_prediction, {palette:'red'}, 'Predicted Israeli Architectural Complex');\n\n// Validate the model with the validation dataset and classify the samples\nvar validated = validation.classify(model);\n\n// Compute the error matrix for the validation results to assess the accuracy\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\n// Print the confusion matrix to the console for evaluation\nprint('Confusion Matrix ', testAccuracy);\n\n// ---------------------------------------------------------------------------------\n// End of part4\n// ---------------------------------------------------------------------------------\nThe model’s accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.\nHowever, during the annotation and recognition process, we made an unexpected discovery that most newly developed lands were developed by Israel, and it would be almost impossible for Palestine to engage in new land excavation.\nTherefore, we did not use the part4 results for filtering, and we believed that the points obtained by part3 were sufficient for users. These points include only Israel and the desert, with the desert concentrated on the east side and easily distinguishable by the human eye. Applying part4 filtering may result in correct objects being excluded, which is less acceptable than deserts being included.\n\n\n\nThis code segment primarily establishes and configures a user interface (UI) panel for interactively displaying and managing map layers. The panel allows users to select from various map layers such as “West Bank Border”, “SAVI”, “Change Detection”, and “New Israeli Settlement Locations” through a dropdown menu. The interface updates the displayed map layers and associated information based on the user’s selection.\nAdditionally, the panel includes a slider for selecting years, which influences the displayed content of map layers, such as SAVI indices or change detection results. Moreover, the panel supports the display of additional control elements like information buttons and year labels, which are displayed conditionally depending on the currently selected map layer.\nThese controls are dynamically managed through written functions, such as showing and hiding specific controls, updating map layers, or handling map click events, thereby enhancing user interaction.\n\n\n\nUI Panel\n\n\n// ---------------------------------------------------------------------------------\n// Beginning of part5\n// Developed by Junrun Chen \n// Beautified by Xiaolin Liu\n// ---------------------------------------------------------------------------------\n\n//////////////////////////////////////////////////////////////////////////////////\n// create UI Panel\nvar panel = ui.Panel();\npanel.style().set({\n  width: '400px',\n  padding: '8px'\n});\nui.root.insert(0, panel);\n\n// Layer select change event handler\nvar layerSelect = ui.Select({\n  items: ['West Bank Border', 'SAVI', 'Change detection', 'Predicted Israeli Architectural Complex','New Israeli Building Clusters'],\n  onChange: handleLayerChange\n});\n\n// Function to handle layer changes\nfunction handleLayerChange(selected) {\n  currentLayer = selected;\n  var showSlider = selected === 'SAVI' || selected === 'Change detection'|| selected === 'New Israeli Building Clusters';\n  var showChart = selected === 'SAVI'; // Only show chart for SAVI layer\n  var showLabels = selected === 'SAVI' || selected === 'Change detection'|| selected === 'New Israeli Building Clusters';\n  var showInfoButton = selected === 'Predicted Israeli Architectural Complex';\n\n  // Update the visibility of UI components\n  //toggleInfoButton.style().set('shown', showInfoButton);\n  //updateLabelPanelVisibility(showLabels);\n  yearSlider.style().set('shown', showSlider);\n  yearLabel.style().set('shown', showSlider);\n  \n  // Reset and update map layers\n  Map.layers().reset();\n  updateMapLayers(selected);\n\n  // Update the display of charts\n  if (showChart) {\n    updateChart(yearSlider.getValue());\n  } else {\n    clearChart();\n  }\n\n  // Display the confusion matrix if required\n  if (selected === 'West Bank Border'){\n    \n    // New Israeli Settlement Identification\n    var boldText = ui.Label({\n      value: 'New Israeli Settlement Identification In The West Bank',\n      style: {fontWeight: 'bold', fontSize: '14px'}\n    });\n    panel.add(boldText); \n\n    // Description 1\n    var description1 = ui.Label({\n      value: 'Users can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. Users are free to explore what is happening at each step.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    var link = ui.Label({\n      value: 'For more information:  https://www.aljazeera.com/news/2021/5/18/mapping-israeli-occupation-gaza-palestine',\n      style:{fontSize:'12px',color: '000129'}\n    })\n    panel.add(link);\n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Instructions:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var instruction = ui.Label({\n      value:'We can toggle between layers using the “Layers” button in the top right corner of the map. Blue represents the Palestinian-controlled areas, red represents the Palestinian-Israeli controlled areas, and the rest of the West Bank is under full Israeli control.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var note = ui.Label({\n      value:'We can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n    \n    currentWidgets.push(boldText,description1,link,title1,instruction,note);\n  }\n\n  if (selected === 'Predicted Israeli Architectural Complex'){\n      var errorMatrix = validated.errorMatrix('class', 'classification');\n      displayConfusionMatrix(errorMatrix);\n  }\n  \n  if (selected === 'SAVI'){\n    \n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'Israeli outposts and early settlements often appear as bare land. Based on this characteristic, SAVI can efficiently and accurately identify target lands, outperforming machine learning in both speed and accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    // Note\n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'By dragging the slider, users can view the identification results for different years. Although not the direct purpose of this application, we also provide visualization of the SAVI index to help users understand the trends in bare land changes and the proportions in different years.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var description = ui.Label({\n      value:'The image is presented in red and black, with red representing our target identified lands. After zooming and moving the image, users can see some clear lines and shapes emerging. Lines indicate unhardened roads, and shapes represent bare land. These likely correspond to the early Israeli settlements.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description);\n    \n    currentWidgets.push(title1,Purpose,title2,instruction,description);\n  }\n  \n  if (selected === 'Change detection'){\n    \n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'SAVI detection results include existing bare land and extensive permanent deserts. The application aims to identify new settlements, thus necessitating the exclusion of these perennially bare areas. By calculating the difference between SAVI images from consecutive years, we can isolate the changed areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n\n    panel.add(toggleRegionButton);  \n    currentWidgets.push(title1,Purpose,title2,instruction,toggleRegionButton);\n  }\n\n  if (selected === 'Predicted Israeli Architectural Complex'){\n    \n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value: 'After identifying the coordinates of all target type land, it is necessary to distinguish land ownership. Directly labeling bare land is inefficient and challenging, so we utilize a novel approach using historical satellite images. While bare land in Israel lacks distinctive features, Israeli buildings significantly differ from those in Palestine. Historical images of locations with Israeli buildings will inevitably show bare land. By labeling and classifying these buildings, we can attribute the land to Israeli ownership.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var description1 = ui.Label({\n      value:'The image on the right, where red indicates the predicted Israeli building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);\n    \n    var description2 = ui.Label({\n      value:'The table on the left is the confusion matrix of the classification results. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description2);    \n    \n    var description3 = ui.Label({\n      value:'Class 1 is Israel building clusters. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description3);        \n\n    var description4 = ui.Label({\n      value:'Class 2 is Palestinian building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description4);        \n\n    var description5 = ui.Label({\n      value:'Class 3 is the desert areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description5);   \n    var description6 = ui.Label({\n      value:'The accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description6);   \n\n    currentWidgets.push(title1,Purpose,title2,description1,description2,description3,description4,description5,description6);\n  }\n  \n  if (selected === 'New Israeli Building Clusters'){\n\n    // Description 1\n    var description1 = ui.Label({\n      value:'We can use the slider on the upper left to switch between different years to view the distribution of recognition results. The left panel provides a visualization of the current year and the trend of changes to facilitate user data query.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Note:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var note = ui.Label({\n      value:'By filtering the shapes and areas within the change detection results, the application extracts the centroids of various geometric shapes corresponding to Israeli settlements established in different years. Given the broad span of years, users can observe that some settlements have developed into towns. Users can toggle between years to view the latest settlements or those that have been fully established. Due to limitations in the filtering logic, some desert changes and agricultural land transformations are not fully filtered out. In the future, new methods will be sought to optimize accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n\n    currentWidgets.push(description1,title1,note);\n  }\n}\n\n// Add controls to the panel\npanel.add(ui.Label('Layer Selector:', {fontWeight: 'bold'}));\npanel.widgets().set(1,layerSelect);\n\nvar currentWidgets = [];  // Array to store current widgets for easy removal\n\n// Create a slider to select the year\nvar yearSlider = ui.Slider({\n  min: 2017,\n  max: 2022,\n  value: 2018,\n  step: 1,\n  style: {stretch: 'horizontal', shown: false}\n});\nvar yearLabel = ui.Label('Chozen Year:', {fontWeight: 'bold', shown: false});\nyearLabel.setValue('Chozen Year: ' + yearSlider.getValue());\npanel.widgets().set(2,yearLabel);\npanel.widgets().set(3,yearSlider);\n\nvar currentLayer = '';\n\n// Create an info panel\nvar infoPanel = ui.Panel({\n  style: {\n    position: 'bottom-left',\n    width: '300px',\n    maxHeight: '400px',\n    padding: '8px',\n    backgroundColor: 'Black',\n    shown: false\n  }\n});\n\n// Create a button to toggle the display of information\nvar toggleInfoButton = ui.Button({\n  label: 'Show/Hide Information',\n  onClick: function() {\n    var shown = infoPanel.style().get('shown');\n    infoPanel.style().set('shown', !shown);\n  },\n  style: {\n    shown: false\n  }\n});\npanel.add(toggleInfoButton);\n\n\nconsole.log(diffImages);\n\nfunction countChanges(diffImage, geometry) {\n  var histogram = diffImage.reduceRegion({\n    reducer: ee.Reducer.frequencyHistogram(),\n    geometry: geometry,\n    scale: 30,\n    maxPixels: 1e9\n  }).get('SAVI');\n\n  return ee.Dictionary(histogram);\n}\n\nvar changeData = [];\n\nvar years = ['2017_2018', '2018_2019', '2019_2020', '2020_2021', '2021_2022', '2022_2023'];\nyears.forEach(function(year) {\n  var diffImage = diffImages.get(year);\n  var stats = countChanges(ee.Image(diffImage), study_area);\n  changeData.push(stats);\n});\n\nvar changeFc = ee.FeatureCollection(changeData.map(function(item, index) {\n  return ee.Feature(null, {\n    'year': years[index],\n    'increased': item.getNumber('1'),\n    'decreasedUnchanged': item.getNumber('0')\n  });\n}));\n\n\nvar changeChart = ui.Chart.feature.byFeature({\n  features: changeFc,\n  xProperty: 'year',\n  yProperties: ['increased', 'decreasedUnchanged']\n}).setOptions({\n  title: 'Yearly SAVI Changes',\n  vAxis: {title: 'Pixel Count'},\n  hAxis: {title: 'Year'},\n  lineWidth: 1,\n  series: {\n    0: {color: 'green'},  \n    1: {color: 'red'}     \n  }\n});\nvar saviregion\n// Start with study_area as the default active region\nvar activeGeometry = study_area;\n// Button to toggle between study_area and saviregion\nvar toggleRegionButton = ui.Button('Switch Area');  // Initial label setup\n\ntoggleRegionButton.onClick(function() {\n  // Toggle the active geometry\n  handleLayerChange(currentLayer);\n  activeGeometry = (activeGeometry === study_area) ? saviregion : study_area;\n  \n  // Update the label of the button\n  var newLabel = 'Active Geometry: ' + (activeGeometry === study_area ? 'Default Area' : 'Custom Region');\n  toggleRegionButton.setLabel(newLabel);\n\n\n});\n\n// Global variable to store the reference of the clicked point layer\nvar clickedPointLayer = null;\n\nfunction mapClickHandler(coords) {\n  if (currentLayer === 'Change detection') {\n  var point = ee.Geometry.Point([coords.lon, coords.lat]);\n  // Adjust this buffer radius as needed or use it directly for point-based analysis\n  saviregion = point.buffer(1000);  // 1000 meter buffer around the clicked point\n\n  // Clear previous clicked point from the map (optional)\n  if (clickedPointLayer !== null) {\n    Map.layers().remove(clickedPointLayer);\n  }\n  // Define the style for the point\n  var pointStyle = {color: 'green', fillColor: '00000000'};\n\n  // Add the point to the map with style\n  clickedPointLayer = Map.addLayer(point, pointStyle, 'Clicked Point');\n\n  // Additional actions based on current layer type\n\n  }\n}\n\n// Register map click event\nMap.onClick(mapClickHandler);\n\nfunction resetYearselector() {\n      panel.remove(yearLabel);\n      panel.remove(yearSlider);\n      panel.add(yearLabel);\n      panel.add(yearSlider);\n}\n\nvar currentLegend = null;\nvar diffimage\n\n\nfunction addLegendWithAnnotations(options,clearExisting) {\n  var title = options.title;\n  var palette = options.palette;\n  var annotations = options.annotations;\n  var position = options.position;\n\n  if (clearExisting && currentLegend) {\n    Map.remove(currentLegend);\n    currentLegend = null;\n  }\n\n  var legend = ui.Panel({\n    style: {\n      position: position,\n      padding: '8px',\n      backgroundColor: 'white'\n    }\n  });\n  \n  var legendTitle = ui.Label({\n    value: title,\n    style:{fontWeight: 'bold'}\n  });\n  legend.add(legendTitle);\n  \n  var colorBlocksPanel = ui.Panel({\n    layout: ui.Panel.Layout.flow('vertical')\n  });\n  \n  var lineHeight = 24; // Increased line height for better readability\n  var totalHeight = palette.length * lineHeight; // Total height of the legend\n  \n  colorBlocksPanel.style().set('height', totalHeight + 'px'); // Set the height of the color block panel\n  \n  palette.forEach(function(color, index) {\n    var colorBlockPanel = ui.Panel({\n      layout: ui.Panel.Layout.flow('horizontal') // Each color block and annotation on the same line\n    });\n    \n    var colorBlock = ui.Label('', {\n      backgroundColor: color,\n      padding: '6px',\n      margin: '4px 4px 0 0', // Increase right margin\n      width: '20px', // Increase width\n      height: '20px' // Increase height\n    });\n    colorBlockPanel.add(colorBlock);\n    \n    var annotationLabel = ui.Label(annotations[index], {\n      margin: '0' // Remove unnecessary margins\n    });\n    colorBlockPanel.add(annotationLabel);\n    \n    colorBlocksPanel.add(colorBlockPanel);\n  });\n  \n  legend.add(colorBlocksPanel);\n  currentLegend = legend;\n  Map.add(legend);\n}\n\n// Function used to update the map display based on the selected layer\nfunction updateMapLayers(selected) {\n  Map.setOptions(\"satellite\");\n  var darkLayer = ee.Image.constant(0).visualize({palette: ['000000'], opacity: 0.5}); \n  Map.addLayer(darkLayer, {}, 'Dark Layer'); \n  Map.setZoom(13);\n  removeChart();\n  var endYear = yearSlider.getValue() + 1\n  var year = yearSlider.getValue();\n  // Clear specific widgets related to the confusion matrix\n        currentWidgets.forEach(function(widget) {\n            panel.remove(widget);\n        });\n        currentWidgets = [];  // Reset the widget tracker\n  switch (selected) {\n    case 'West Bank Border':\n      addLegendWithAnnotations({\n      title: 'West Bank Border',\n      palette: ['07C7F2','F2055C','260B10'],\n      annotations: ['Palestinian-controlled','Palestinian-Israeli controlled','Israeli-controlled'],\n      position: 'bottom-right'\n      }, true);\n      Map.setCenter(35.5, 32.1, 9)\n      Map.addLayer(westbank, {color:'260B10'}, 'West Bank Border',1,0.9);\n      Map.addLayer(areaB, {color:'F2055C'}, 'Area B',1,0.8);\n      Map.addLayer(areaA, {color:'07C7F2'}, 'Area A',1,0.8);\n      break;\n    case 'SAVI':\n      //clearChart();\n      addLegendWithAnnotations({\n      title: 'SAVI',\n      palette: ['F20519','260B10'],\n      annotations: ['Bare Land', 'Other'],\n      position: 'bottom-right'\n      }, true);\n      resetYearselector();\n      var savi_image = ee.Image(savi_2017_2023.get(yearSlider.getValue().toString()));\n      Map.addLayer(savi_image, visdiff, 'SAVI_' + yearSlider.getValue().toString()+ '_'+ endYear); \n      break;\n    case 'Change detection':\n      //clearChart();\n      addLegendWithAnnotations({\n      title: 'Difference',\n      palette: ['F20519', '260B10'],\n      annotations: ['Changed Area', 'Unchanged Area'],\n      position: 'bottom-right'\n      }, true);\n      resetYearselector();\n      var startYear = yearSlider.getValue(); \n      panel.widgets().forEach(function(widget) {\n        if (widget instanceof ui.Label && widget.getValue() === 'Please select a year after 2017 for the end year to see the changes found this year.') {\n          panel.remove(widget);\n        }\n        \n      });\n      var endYear = startYear + 1; \n      var diffKey = startYear.toString() + '_' + endYear.toString();\n      var diff_image = ee.Image(diffImages.get(diffKey));\n      Map.addLayer(diff_image, visdiff, 'Difference_' + diffKey); \n      diffimage = diff_image;\n      \n      break;\n    case 'Predicted Israeli Architectural Complex':\n      addLegendWithAnnotations({\n      title: 'Predicted Israeli Architectural Complex',\n      palette: ['5821A6'],\n      annotations: ['Predicted Israeli Building'],\n      position: 'bottom-right'\n      }, true);\n      Map.addLayer(westbank, {palette: '260B10'}, 'West Bank Border',1,0.8);\n      Map.addLayer(Israeli_prediction, {palette: '5821A6'}, 'Predicted Israeli Architectural Complex',true); // 在这里添加预测建筑图层的图例\n      break;\n    case 'New Israeli Building Clusters':\n      addLegendWithAnnotations({\n      title: 'New Israeli Building Clusters',\n      palette: ['F2B33D'],\n      annotations: ['Centroids'],\n      position: 'bottom-right'\n      }, true);\n      resetYearselector();\n      Map.addLayer(centroidLayers[yearSlider.getValue()], {color: 'F2B33D'}, 'Centroids' + yearSlider.getValue() +\"-\"+ endYear);\n      break;\n  }\n\n}\n\nui.root.add(infoPanel);\nvar errorMatrix = validated.errorMatrix('class', 'classification');\n\n// Default display of the initial year's layer\nupdateMapLayers('West Bank Border');\nlayerSelect.setValue('West Bank Border', true);\n\n// Function to update or clear chart based on current layer\n// Calculate the number of pixels with SAVI=1 for each year from 2017 to 2023 and add a line chart to the existing panel\n\nvar savedChart;\nfunction calculateSAVI1Counts() {\n  var counts = []; // Array to store counts for each year\n\n  // Iterate through each year\n  for (var year = 2017; year &lt;= 2023; year++) {\n    var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n\n    // Create a mask for SAVI values equal to 1\n    var mask1 = selectedYearImage.eq(1);\n\n    // Apply the mask\n    var image1 = selectedYearImage.updateMask(mask1);\n\n    // Calculate the number of pixels with SAVI value equal to 1\n    var countPixels1 = image1.reduceRegion({\n      reducer: ee.Reducer.count(),\n      geometry: activeGeometry,\n      scale: 30,\n      maxPixels: 1e9\n    });\n\n    // Add each year's result to the array\n    counts.push({\n      'year': year,\n      'count': countPixels1.get('SAVI')\n    });\n  }\n\n  // Convert the results array to a FeatureCollection\n  var countFeatures = ee.FeatureCollection(counts.map(function(item) {\n    return ee.Feature(null, item);\n  }));\n\n  // Create a line chart\n  var countChart = ui.Chart.feature.byFeature({\n    features: countFeatures,\n    xProperty: 'year',\n    yProperties: ['count']\n  })\n  .setOptions({\n    title: 'SAVI = 1 Pixel Counts from 2017 to 2023',\n    hAxis: {title: 'Year'},\n    vAxis: {title: 'Count of Pixels'},\n    lineWidth: 1,\n    pointSize: 3\n  });\n\n  // Add the chart to the existing panel\n  panel.widgets().add(countChart);\n  savedChart = countChart;\n}\n\n// Function to remove the chart\nfunction removeChart() {\n  if (savedChart) {\n    panel.widgets().remove(savedChart);\n    savedChart = null; // Clear the reference, indicating that there is currently no chart\n  }\n}\n\nfunction updateChart(year) {\n  removeChart();\n  var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n  // Create masks for SAVI values 0 and 1\n  var mask0 = selectedYearImage.eq(0);\n  var mask1 = selectedYearImage.eq(1);\n\n  // Apply masks to the original image\n  var image0 = selectedYearImage.updateMask(mask0);\n  var image1 = selectedYearImage.updateMask(mask1);\n\n  // Generating a histogram for SAVI values\n  var histogramChart = ui.Chart.image.histogram({\n    image: ee.Image.cat([image0.select('SAVI'), image1.select('SAVI')]),\n    region: activeGeometry,\n    scale: 30,\n    minBucketWidth: 0.001,  // Each bucket corresponds exactly to one SAVI value\n  }).setOptions({\n    title: year + ' SAVI Value Distribution',\n    vAxis: {title: 'Pixel Count'},\n    hAxis: {title: 'SAVI', ticks: [{v:0, f:'0'}, {v:1, f:'1'}]}, // Explicitly show only 0 and 1\n    series: {\n      0: {color: 'blue', label: 'SAVI = 0'},  // Color and label for SAVI value 0\n      1: {color: 'red', label: 'SAVI = 1'}    // Color and label for SAVI value 1\n    },\n    bar: {groupWidth: \"20%\"}  // Adjust the width of the bars\n  });\n\n  // Count and print the number of pixels with SAVI = 1\n  var countPixels1 = image1.reduceRegion({\n    reducer: ee.Reducer.count(),\n    geometry: activeGeometry,\n    scale: 30,\n    maxPixels: 1e9\n  });\n\n  // Check if there is already a chart at the expected position in the panel and replace it or add the new chart.\n  if (panel.widgets().length() &gt; 2) {\n    panel.widgets().set(2, histogramChart); // Replace the existing chart\n  } else {\n    panel.widgets().insert(2, histogramChart); // Add the chart if not already present\n  }\n  //panel.widgets().remove(countChart);\n  calculateSAVI1Counts();\n}\n\n// Function to clear the chart\nfunction clearChart() {\n  if (panel.widgets().length() &gt; 2) {\n    panel.remove(panel.widgets().get(2));  // Remove the chart widget\n  }\n}\n\n// Slider event handling\nyearSlider.onSlide(function(value) {\n  \n  yearLabel.setValue('Chozen Year: ' + value);\n  // Retrieve the differential image for the selected year and the next year.\n\n  handleLayerChange(currentLayer);\n  \n  // If the current layer requires a specific description, it is handled here\n  if (currentLayer === 'West Bank Border') {\n    updateDescriptionForWestBankBorder();\n  } else if (currentLayer === 'SAVI') {\n    updateChart(value); // Update chart only if SAVI is currently selected\n    updateDescriptionForSAVI();\n  } else if (currentLayer === 'Change detection') {\n\n    updatePieChart(diffimage, activeGeometry);\n    //updateChangeChart(diffImages, activeGeometry);\n    //panel.widgets().set(8, diffchart);\n    //updateLineChart(diffImages, activeGeometry);\n    updateDescriptionForChangeDetection();\n    if(!layerSelect){panel.add(layerSelect);}\n  } else if (currentLayer === 'Predicted Israeli Architectural Complex') {\n    updateDescriptionForPredictedIsraeliArchitecturalComplex();\n  } else if (currentLayer === 'New Israeli Building Clusters') {\n    updateDescriptionForCenters();\n    displayCentroidScatter(results.centroidLayers, yearSlider.getValue());\n  }\n\n});\n\n// Helper functions to manage descriptions for different layers\nfunction updateDescriptionForWestBankBorder() {\n  clearDescriptions();\n    // New Israeli Settlement Identification\n    var boldText = ui.Label({\n      value: 'New Israeli Settlement Identification In The West Bank',\n      style: {fontWeight: 'bold', fontSize: '14px'}\n    });\n    panel.add(boldText); \n\n    // Description 1\n    var description1 = ui.Label({\n      value: 'Users can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. Users are free to explore what is happening at each step.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    var link = ui.Label({\n      value: 'For more information:  https://www.aljazeera.com/news/2021/5/18/mapping-israeli-occupation-gaza-palestine',\n      style:{fontSize:'12px',color: '000129'}\n    })\n    panel.add(link);\n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Instructions:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var instruction = ui.Label({\n      value:'We can toggle between layers using the “Layers” button in the top right corner of the map. Blue represents the Palestinian-controlled areas, red represents the Palestinian-Israeli controlled areas, and the rest of the West Bank is under full Israeli control.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var note = ui.Label({\n      value:'We can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n    \n    currentWidgets.push(boldText,description1,link,title1,instruction,note);\n}\n\nfunction updateDescriptionForSAVI() {\n  clearDescriptions();\n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'Israeli outposts and early settlements often appear as bare land. Based on this characteristic, SAVI can efficiently and accurately identify target lands, outperforming machine learning in both speed and accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    // Note\n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'By dragging the slider, users can view the identification results for different years. Although not the direct purpose of this application, we also provide visualization of the SAVI index to help users understand the trends in bare land changes and the proportions in different years.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var description = ui.Label({\n      value:'The image is presented in red and black, with red representing our target identified lands. After zooming and moving the image, users can see some clear lines and shapes emerging. Lines indicate unhardened roads, and shapes represent bare land. These likely correspond to the early Israeli settlements.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description);\n    \n    currentWidgets.push(title1,Purpose,title2,instruction,description);\n}\n\nfunction updateDescriptionForChangeDetection() {\n  clearDescriptions();\n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'SAVI detection results include existing bare land and extensive permanent deserts. The application aims to identify new settlements, thus necessitating the exclusion of these perennially bare areas. By calculating the difference between SAVI images from consecutive years, we can isolate the changed areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n\n    panel.add(toggleRegionButton);  \n    currentWidgets.push(title1,Purpose,title2,instruction,toggleRegionButton);\n}\n\nfunction updateDescriptionForPredictedIsraeliArchitecturalComplex() {\n  clearDescriptions();\n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value: 'After identifying the coordinates of all target type land, it is necessary to distinguish land ownership. Directly labeling bare land is inefficient and challenging, so we utilize a novel approach using historical satellite images. While bare land in Israel lacks distinctive features, Israeli buildings significantly differ from those in Palestine. Historical images of locations with Israeli buildings will inevitably show bare land. By labeling and classifying these buildings, we can attribute the land to Israeli ownership.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var description1 = ui.Label({\n      value:'The image on the right, where red indicates the predicted Israeli building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);\n    \n    var description2 = ui.Label({\n      value:'The table on the left is the confusion matrix of the classification results. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description2);    \n    \n    var description3 = ui.Label({\n      value:'Class 1 is Israel building clusters. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description3);        \n\n    var description4 = ui.Label({\n      value:'Class 2 is Palestinian building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description4);        \n\n    var description5 = ui.Label({\n      value:'Class 3 is the desert areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description5);   \n    var description6 = ui.Label({\n      value:'The accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description6);   \n\n    currentWidgets.push(title1,Purpose,title2,description1,description2,description3,description4,description5,description6);\n}\n\nfunction updateDescriptionForCenters() {\n  clearDescriptions();\n\n    // Description 1\n    var description1 = ui.Label({\n      value:'We can use the slider on the upper left to switch between different years to view the distribution of recognition results. The left panel provides a visualization of the current year and the trend of changes to facilitate user data query.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Note:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var note = ui.Label({\n      value:'By filtering the shapes and areas within the change detection results, the application extracts the centroids of various geometric shapes corresponding to Israeli settlements established in different years. Given the broad span of years, users can observe that some settlements have developed into towns. Users can toggle between years to view the latest settlements or those that have been fully established. Due to limitations in the filtering logic, some desert changes and agricultural land transformations are not fully filtered out. In the future, new methods will be sought to optimize accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n\n    currentWidgets.push(description1,title1,note);\n}\n\n// Function to clear previously added descriptions\nfunction clearDescriptions() {\n  currentWidgets.forEach(function(widget) {\n    panel.remove(widget);\n  });\n  currentWidgets = [];  // Reset the widget tracker\n}\n\n// Function to display confusion matrix\nfunction displayConfusionMatrix(errorMatrix) {\n  // Clear previously added widgets from the panel\n  currentWidgets.forEach(function(widget) {\n    panel.remove(widget);\n  });\n  currentWidgets = [];  // Reset the array after clearing\n\n  var matrixArray = errorMatrix.array();\n  // Define custom labels for the matrix categories\n  var labels = ['Israel', 'Palestine', 'Joint Administration'];\n\n  var matrixChart = ui.Chart.array.values({\n    array: matrixArray,\n    axis: 0,\n    xLabels: labels  // Use descriptive labels for the x-axis\n  }).setChartType('Table').setOptions({\n    title: 'Confusion Matrix',\n    hAxis: {\n      title: 'Predicted Label',\n      ticks: labels.map(function(label, index) { return {v: index, f: label}; })  // Custom tick labels\n    },\n    vAxis: {\n      title: 'Actual Label',\n      ticks: labels.map(function(label, index) { return {v: index, f: label}; })  // Custom tick labels\n    },\n    colors: ['yellow', 'red', 'green']\n  });\n\n  panel.add(matrixChart);  // Display the chart\n  currentWidgets.push(matrixChart);  // Store references to remove later\n}\n\nfunction updatePieChart(diffImage, geometry) {\n  currentWidgets.forEach(function(widget) {\n        panel.remove(widget);\n    });\n  currentWidgets = [];  // Reset the array after clearing\n  var stats = diffImage.reduceRegion({\n    reducer: ee.Reducer.frequencyHistogram(),\n    geometry: geometry,\n    scale: 30,\n    maxPixels: 1e9\n  });\n  console.log(diffimage);\n  // Asynchronously evaluate the histogram calculation\n  stats.evaluate(function(result) {\n    if (result.SAVI) {\n      var data = [['Change Type', 'Area']];\n      var totalIncreased = result.SAVI['1'] || 0; // Ensure default if undefined\n      var totalDecreasedUnchanged = result.SAVI['0'] || 0; // Ensure default if undefined\n      data.push(['Increased', totalIncreased]);\n      data.push(['Decreased/Unchanged', totalDecreasedUnchanged]);\n\n      // Create the chart directly from the array\n      var chart = ui.Chart(data)\n        .setChartType('PieChart')\n        .setOptions({\n          title: 'Proportion of SAVI Change' + yearSlider.getValue(),\n          slices: {\n            0: {color: 'red'},  // Decreased or unchanged\n            1: {color: 'green'} // Increased\n          },\n          pieSliceText: 'percentage',\n          is3D: true,\n          fontSize: 12\n        });\n      // Replace or add the chart in the UI panel\n      if (panel.widgets().length() &gt; 2) {\n        panel.widgets().set(7, chart); // Assume the second position for the chart\n        //panel.widgets().set(8,changeChart);\n        currentWidgets.push(chart);\n      }\n    } else {\n      console.log(\"No data available for the specified range.\");\n    }\n  });\n\n  updateChangeChart(diffImages, activeGeometry);\n  //console.log(panel);\n}\n\nvar diffchart\n// Function to update the line chart for SAVI changes over the years\nfunction updateChangeChart(diffImages, geometry) {\n  // Collect data for each year and compute changes\n  var changeData = ee.List([]);\n  var years = ['2017_2018', '2018_2019', '2019_2020', '2020_2021', '2021_2022', '2022_2023'];\n\n  years.forEach(function(year) {\n    var diffImage = ee.Image(diffImages.get(year));\n    var stats = diffImage.reduceRegion({\n      reducer: ee.Reducer.frequencyHistogram(),\n      geometry: geometry,\n      scale: 30,\n      maxPixels: 1e9\n    }).get('SAVI');\n\n    var data = ee.Dictionary(stats);\n    var increased = data.getNumber('1').getInfo();\n    var decreasedUnchanged = data.getNumber('0').getInfo();\n    \n    changeData = changeData.add(ee.Feature(null, {\n      'year': year,\n      'increased': increased,\n      'decreasedUnchanged': decreasedUnchanged\n    }));\n  });\n\n  // Convert list to feature collection for charting\n  var changeFc = ee.FeatureCollection(changeData);\n\n  // Create and display the chart\n  var changeChart = ui.Chart.feature.byFeature({\n    features: changeFc,\n    xProperty: 'year',\n    yProperties: ['increased', 'decreasedUnchanged']\n  }).setOptions({\n    title: 'Yearly Difference',\n    vAxis: {title: 'Pixel Count'},\n    hAxis: {title: 'Year'},\n    lineWidth: 1,\n    series: {\n      0: {color: 'green'},  // SAVI increased\n      1: {color: 'red'}     // SAVI decreased or unchanged\n    }\n  });\n  //diffchart = changeChart;\n\n  // Check if a chart already exists in the UI, replace or add\n \n    panel.widgets().add(changeChart);\n    currentWidgets.push(diffchart);\n\n  //console.log(panel);\n}\n\nfunction displayChangeHistogram(yearlyImages, year, geometry) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((parseInt(year) + 1).toString()));\n    \n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n    var filteredChange = filterSmallPatches(transitionToRed, 100);\n    \n    var areaHistogram = filteredChange.reduceRegion({\n        reducer: ee.Reducer.frequencyHistogram(),\n        geometry: geometry,\n        scale: 30,\n        maxPixels: 1e9\n    });\n\n    areaHistogram.evaluate(function(result) {\n        var chart = ui.Chart.array.values({\n            array: Object.values(result.SAVI),\n            axis: 0,\n            xLabels: Object.keys(result.SAVI)\n        }).setOptions({\n            title: 'Distribution of Change Areas for ' + year,\n            vAxis: {title: 'Frequency'},\n            hAxis: {title: 'Area Size (pixels)'},\n            series: {0: {color: 'red'}}\n        });\n\n        // Display chart\n        if (panel.widgets().length() &gt; 5) {\n            panel.widgets().set(5, chart);\n        } else {\n            panel.add(chart);\n        }\n    });\n}\n\nconsole.log(centroidLayers);\n\nfunction displayCentroidScatter(centroidLayers, year) {\n    var centroids = centroidLayers[year];\n    \n    var centroidChart = ui.Chart.feature.byFeature(centroids, 'longitude', ['latitude'])\n        .setChartType('ScatterChart')\n        .setOptions({\n            title: 'Centroids of Changed Areas in ' + year,\n            hAxis: {title: 'Longitude'},\n            vAxis: {title: 'Latitude'},\n            pointSize: 5,\n            colors: ['yellow']  // Points in yellow\n        });\n\n    // Display chart\n    if (panel.widgets().length() &gt; 2) {\n        panel.widgets().add(centroidChart);\n    } else {\n        panel.add(centroidChart);\n    }\n    countAndChartCentroids(centroidLayers);\n}\n\n\n//Create an information panel to display feature attributes, and set it to not be displayed initially\nvar infoPanel = ui.Panel({\n   style: {\n     position: 'bottom-left',\n     width: '300px',\n     maxHeight: '400px',\n     padding: '8px',\n     backgroundColor: 'white',\n     shown: false //Initially set to not show\n   }\n});\n\n//Create a switch button to control the display and hiding of the information panel\nvar infotoggleButton = ui.Button({\n   label: 'Show/hide Region information',\n   onClick: function() {\n     //Switch the display state of the information panel\n     var shown = infoPanel.style().get('shown');\n     infoPanel.style().set('shown', !shown);\n     infotoggleButton.setLabel(shown ? 'Show Region info' : 'Hide Region info');\n   },\n   style: {\n     padding: '0',\n     margin: '0',\n     backgroundColor: '#ffffff00', // Completely transparent background\n     color: '#000000', //Set the text color to black, which can be changed as needed\n     fontSize: '12px', // Font size, can be adjusted as needed\n     border: '0px solid' // Remove border\n   }\n});\n\n\n//Define a function to update the panel to display the clicked characteristic attributes when the map is clicked.\nfunction showFeatureInfo(coords) {\n   var point = ee.Geometry.Point([coords.lon, coords.lat]);\n   var feature = westbank.filterBounds(point).first();\n\n   feature.evaluate(function(feature) {\n     if (feature) {\n       // Clear old attribute information\n       infoPanel.clear();\n\n       // Iterate through the properties of the feature, create a UI element for each property and add it to the panel\n       var table = ui.Panel({\n         layout: ui.Panel.Layout.flow('vertical'),\n         style: {margin: '0 -8px'}\n       });\n\n       Object.keys(feature.properties).forEach(function(key) {\n         var value = feature.properties[key];\n         var row = ui.Panel({\n           layout: ui.Panel.Layout.flow('horizontal'),\n           style: {\n             border: '1px solid black',\n             textAlign: 'left',\n             padding: '2px'\n           }\n         });\n\n         var labelKey = ui.Label({\n           value: key + ':',\n           style: {margin: '0 4px', fontWeight: 'bold', width: 'auto', padding: '2px'}\n         });\n\n         var labelValue = ui.Label({\n           value: value.toString(),\n           style: {margin: '0 4px', width: 'auto', padding: '2px'}\n         });\n\n         row.add(labelKey);\n         row.add(labelValue);\n         table.add(row);\n       });\n\n       infoPanel.add(table);\n     }\n   });\n}\n\n//Set the map click event listener\nMap.onClick(showFeatureInfo);\n\n//Create a panel to hold the information panel and switch button\nvar mappanel = ui.Panel({\n   layout: ui.Panel.Layout.flow('vertical'),\n   style: {position: 'bottom-left'}\n});\n\n//Add buttons and information panels to the panel\nmappanel.add(infotoggleButton);\nmappanel.add(infoPanel);\n\n// Finally, add the panel to the map's sidebar\nMap.add(mappanel);\n\nfunction countAndChartCentroids(centroidLayers) {\n  var years = ee.List.sequence(2017, 2022);\n  var chartData = [];\n\n  // Helper function to handle asynchronous retrieval of size\n  function processYear(yearIndex) {\n    if (yearIndex &lt; years.length().getInfo()) { // Check if there are more years to process\n      var year = years.get(yearIndex).getInfo(); // Get the year as a number\n      var centroids = centroidLayers[year];\n      if (centroids) {\n        centroids.size().evaluate(function(size) {\n          console.log('Year: ' + year + ', Count: ' + size); // Log the count\n          chartData.push({year: year, count: size}); // Push the data to the chart data array\n          processYear(yearIndex + 1); // Recursively process the next year\n        });\n      } else {\n        console.log('Year: ' + year + ', Count: 0'); // Log and handle undefined years\n        chartData.push({year: year, count: 0}); // Push zero count\n        processYear(yearIndex + 1); // Recursively process the next year\n      }\n    } else {\n      // All years have been processed, now create and print the chart\n      chartData = chartData.sort(function(a, b) { return a.year - b.year; }); // Sort the chart data\n      var chart = ui.Chart.array.values(chartData.map(function(item) { return item.count; }), 0, chartData.map(function(item) { return item.year; }))\n        .setChartType('ColumnChart')\n        .setOptions({\n          title: 'Number of Centroids Per Year',\n          hAxis: {title: 'Year'},\n          vAxis: {title: 'Number of Centroids'},\n          legend: {position: 'none'}\n        });\n      panel.widgets().add(chart);\n      currentWidgets.push(chart);\n    }\n  }\n  processYear(0); // Start processing from the first year\n}\n\n// ---------------------------------------------------------------------------------\n// End of part5\n// ---------------------------------------------------------------------------------\n\n\n\n\nBroken homes\nData source\nHow Israeli settlers are expanding illegal outposts amid Gaza war\nHow the political maps of Israel and Palestine have changed\nMapping Israeli occupation"
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "New Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "The hot war in Gaza is well known in the Israeli-Palestinian conflict, but the slow erosion of the West Bank has received little attention.\nIn the West Bank of the Jordan River, Israel continues to encroach on Palestinian land by establishing illegal outposts, transforming them into settlements, and eventually legalizing them. The purpose of this application is to detect these new settlements.\nMany journalists hope to mitigate the situation of Palestinian victimization through early intervention and raise public awareness about the status of Palestine beyond Gaza. However, sometimes they manually search for these targets on Google earth. We hope to help them quickly locate these targets through this application.\n\n\nThe purpose of this application is to use satellite imagery to find and mark new Israeli settlements in the West Bank. The target has certain characteristics. Finding a series of methods to filter and mark them with the features is the main problem the application needs to solve.\nFor target users, the application should also provide a user interface in which they can quickly query the location and number of these newly emerged territorial encroachments.\nThrough this application, we hope that it can make a small contribution to arousing a more comprehensive public understanding of the Palestinian-Israeli conflict.\n\n\n\n\nJournalists, researchers and international organizations\n\nMany newly Israeli settlements are illegal. Usually when settlements develop to a certain scale, Israel will declare them legal. Early detection can help the international community intervene earlier. Some reporters did a manual blanket search through Google Earth. We hope this helps them resolve the issue quickly.\n\nPublic\n\nThe public can also use the app to understand how Israel has invaded Palestinian land, ultimately leading to the pockmarked borders of the area’s controlled areas.\nThis news article provides a detailed look at the Israeli-occupied territories.\n\n\n\n\n\n\nHarmonized Sentinel-2 MSI: MultiSpectral Instrument, Level-2A. (Surface Reflectance)\nThe resolution is 10m.\nThe time span is 2017-03-28 – Present.\n\nAlthough our main purpose is to detect only the latest Israeli settlements, to use machine learning to distinguish settlement ownership, the larger the data set, the better. Therefore, we use all available years for identification and training. To make full use of the data, we cut the data by year with 04-01 as the boundary, and then preprocessed the data of each year. For example, the data in 2023 corresponds to 2023-04-01 - 2024-04-01.\n\n\n\nRelated shapefiles of Westbank area.\n\n\n\n\nThis application initially uses the SAVI to identify target land types, then employs change detection to identify newly cultivated land plots that appear each year. These plots include changes in desert areas and minor agricultural land developments. Therefore, it is necessary to use shape and area filtering to select plots of specific areas and shapes, and subsequently pinpoint their central locations. Finally, we attempt to distinguish whether these plots belong to Israel through machine learning.\n\nFeature Selection(NDVI, SAVI), Land Cover Classification(Random Forest)\nChange detection(difference, T-test)\nMorphological Analysis, Area and Shape Filtering\nClassification(Support Vector Machine, Random Forest)\n\n\n\n\nWork Flow\n\n\n\n\n\nThe main function is to provide target points to help users quickly locate the latest settlements or outposts. The left side is the operation panel. Users can select “New Israeli Settlement Locations” button and a specific year to obtain the target position for that year. We also provide quantitative statistics and line charts to help users understand their changing trends.\nAdditionally, users can select other options such as “West Bank Border”, “Control Areas”, “SAVI”, etc. We also provide layers of some background and analysis processes to help users better understand the working principle of the application. Users can freely view these layers, and look for image features that interest them."
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "New Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "// The workflow of this application is clearly step-by-step, making it possible to distribute tasks evenly and reasonably. \n\n// The entire application development is divided into five parts, and each member is responsible for one part.\n\n// In the exploration process, some of the ineffective methods were not reflected in the final application. In order to reflect the contribution of each member, the comments in subsequent code blocks will describe what the members are responsible for and what is not reflected.\n\n// Manual annotation for machine learning is completed by the group.\n\n\nFirst, we extract satellite images from Sentinel-2 and filtering out cloud-obscured ones. These images are then subjected to machine learning analysis to identify surface features such as roads, farmland, forests, cities, and bare land. Various feature collections are imported to provide essential geographical context, including West Bank borders, Palestinian and Israeli-Palestinian control areas, and points indicating illegal appropriation.\n// ---------------------------------------------------------------------------------\n// Beginning of part1\n// Developed by Mingyu Bi \n// Unreflected workload includes attempts to classify land based on RF\n// ---------------------------------------------------------------------------------\n\n\n\n// Import West Bank borders.\nvar westbank = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/WestBankBorder\");\n\n// Import Palestinian control area.\nvar areaA = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaA\");\n\n// Import Israeli-Palestinian control area.\nvar areaB = ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/areaB\");\n\nvar redpoint=ee.FeatureCollection(\"projects/ee-casa0025insightexplorers/assets/illegal_appropriation\")\n\n// Date range.\nvar start='2023-04-01';\nvar end='2024-04-01';\n\n// Bands.\nvar bands = ['B2','B3','B4','B5','B6','B7','B8','B8A','B11','B12'];\n  \n// Filter the Sentinel-2 collection and select the less cloudy image.\nvar sentinel  = ee.ImageCollection('COPERNICUS/S2_HARMONIZED') \n              .filter(ee.Filter.date(start, end))\n              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n              .mean()\n              .select(bands);\n\n// Visualization of sentinel.\nvar sentinel_settings = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nMap.addLayer(sentinel.clip(AOI), sentinel_settings, 'Sentinel',false);\n\n// Visualization of westbank borders.\nvar westbank_settings = {\n  color: 'FFFFFF',\n  fillColor: '00000000',\n};\n\nMap.addLayer(westbank, westbank_settings, 'West Bank Border');\n\n// Study area.\nvar study_area = areaA.merge(areaB);\nvar study_geometry = study_area.union().geometry();\nvar buffered_geometry = study_geometry.buffer(200);\n\nMap.addLayer(buffered_geometry, {color: 'yellow'}, 'Study Area',false);\nFor the purpose of machine learning training in part 4, we need to increase the amount of data, so two functions are defined: one calculates SAVI, and the other retrieves yearly Sentinel-2 images for analysis over time.\n// ---------------------------Create functions.---------------------------\n\n// Function for calculating SAVI.\nfunction SAVI(image) {\n  // Clip area.\n  var sentinel_westbank = image.clip(westbank);\n  var sentinel_study = image.clip(buffered_geometry);\n  \n  // Calculate SAVI.\n  var savi = sentinel_westbank.expression(\n    '(NIR - RED) / (NIR + RED + 0.5) * (1 + 0.5)', {\n      'NIR': sentinel_westbank.select('B8'),\n      'RED': sentinel_westbank.select('B4')\n    }\n  ).rename('SAVI');\n\n  var barelandSAVI = savi.lt(0.2);\n  \n  return barelandSAVI;\n}\n\nfunction YearlyImages(startYear, endYear, dateSuffix, bands) {\n  // Initialize an empty dictionary to store a set of images by year.\n  var yearly_sentinel_images = ee.Dictionary();\n\n  // Loop through each year from startYear to endYear.\n  for (var year = startYear; year &lt;= endYear; year++) {\n    var start = year + dateSuffix;\n    var end = (year + 1) + dateSuffix;\n\n    var sentinel = ee.ImageCollection('COPERNICUS/S2_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n\n    yearly_sentinel_images = yearly_sentinel_images.set(year.toString(), sentinel);\n  }\n\n  return yearly_sentinel_images;\n}\nApply the function to obtain year-by-year images and calculate SAVI. The results are organized into a dictionary for easy call in the next step.\n// ---------------------------Apply the function.---------------------------\n\n// Create yearly images.\nvar sentinel_2017_2023 = YearlyImages(2017, 2023, '-04-01', bands);\n\n// Iterate over the dictionary and apply SAVI function.\nvar savi_2017_2023 = ee.Dictionary();\nvar keys = sentinel_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var image = ee.Image(sentinel_2017_2023.get(key));\n  var savi_image = SAVI(image);\n  savi_2017_2023 = savi_2017_2023.set(key, savi_image); // savi_2017_2023 is the dictionary for Change detection.\n});\n\n// Visualization.\nvar visParams = {\n  min: 0.0,\n  max: 1.0,\n  palette: ['2a2A28', 'FF0000']\n};\n\nvar keys = savi_2017_2023.keys();\nkeys.getInfo().forEach(function(key) {\n  var savi_image = ee.Image(savi_2017_2023.get(key));\n  Map.addLayer(savi_image, visParams, 'SAVI_' + key,false);\n});\n\n// ---------------------------------------------------------------------------------\n// End of part1\n// ---------------------------------------------------------------------------------\n\n\n\nThen, a function called calculateChange is defined, which computes differences in bare land between consecutive years, aiding in identifying new roads or settlements. This function iterates from 2017 to 2023, analyzing each yearly pair and visualizing the changes for deeper understanding.\nThe SAVI analysis result obtained in the previous step is a binary image, so among various methods, direct difference can obtain the best result.\n// ---------------------------------------------------------------------------------\n// Beginning of part2\n// Developed by Xiaolin Liu\n// Unreflected workload includes T-test on different satellite images sets or analysis results\n// ---------------------------------------------------------------------------------\n\n\n\n// Function to calculate change between two images\nfunction calculateChange(image1, image2, year1, year2) {\n  // Calculate the difference between the two images\n  var diff = image2.subtract(image1).abs(); // Taking absolute value of the difference\n  \n  // Visualize the change\n  var layerName = 'Change ' + year1 + ' to ' + year2;\n  Map.addLayer(diff, {min: 0, max: 0.5, palette: ['2A2A28', 'FF0000']}, layerName);\n}\n\n// Iterate over the years and calculate change\nfor (var i = 2017; i &lt; 2023; i++) {\n  var image1 = ee.Image(savi_2017_2023.get(i.toString()));\n  var image2 = ee.Image(savi_2017_2023.get((i + 1).toString()));\n  \n  calculateChange(image1, image2, i, i + 1);\n}\n\n// ---------------------------------------------------------------------------------\n// End of part2\n// ---------------------------------------------------------------------------------\n\n\n\nIn part 2, subtraction will capture the appearance and disappearance of bare land at the same time. Therefore, this section is specifically designed to screen, monitor, and analyze areas where the Soil Adjustment Vegetation Index (SAVI) has decreased over several consecutive years. It starts by identifying areas between adjacent years where the SAVI value has decreased, in order to determine regions of vegetation loss, especially those transitioning from above 0.2 in SAVI to below 0.2.\nAfter these changes are identified, the code applies specific filtering functions to exclude smaller patches, thereby reducing noise and errors to ensure the reliability and accuracy of the results. The filtered areas are displayed in red on the map for direct visualization and analysis. Moreover, the code vectorizes these areas and extracts centroids highlighted in yellow, which are crucial for further geospatial analysis. Ultimately, these centroids and areas are added to the map.\n// ---------------------------------------------------------------------------------\n// Beginning of part3\n// Developed by Xinyu Guo, Yilan Bu \n// Yilan Bu: Optimized the change detection step so that the acquired image is one-way (bare ground appears) and filter\n// Xinyu Guo: Filter and extract the center point of the target geometry\n// ---------------------------------------------------------------------------------\n\n\n\n// Filter out small patches based on connected pixel size.\nfunction filterSmallPatches(image, minPixels) {\n  var connected = image.connectedPixelCount();\n  return image.updateMask(connected.gte(minPixels));\n}\n\n// Function to compare SAVI between two consecutive years, identify changes, and filter small patches.\nfunction compareAndFilterYearlySAVI(yearlyImages, startYear, endYear, minPixels) {\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filtered_change = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create a visualization layer to show these changes.\n    var changeVisualization = filtered_change.updateMask(filtered_change)\n                                             .multiply(255)\n                                             .toByte();\n    var changeParams = {\n      min: 0,\n      max: 255,\n      palette: ['000000', 'FF0000']  // Display changes in red.\n    };\n\n    Map.addLayer(changeVisualization, changeParams, 'Filtered Change to Barren ' + year + '-' + (year+1));\n  }\n}\n\n// Apply the function to compare and filter SAVI across years and visualize changes.\ncompareAndFilterYearlySAVI(savi_2017_2023, 2017, 2023, 100);\n\n// Function to compare SAVI between two consecutive years, identify changes, filter small patches, and extract centroids.\nfunction compareFilterAndExtractCentroids(yearlyImages, startYear, endYear, minPixels) {\n  var changeLayersDict = {}; // Dictionary to hold change layers\n  var centroidLayersDict = {}; // Dictionary to hold centroid layers\n\n  for (var year = startYear; year &lt; endYear; year++) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((year + 1).toString()));\n\n    // Identify areas where SAVI decreased from above 0.2 to below 0.2.\n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n\n    // Filter out small patches from the identified areas.\n    var filteredChange = filterSmallPatches(transitionToRed, minPixels);\n\n    // Create vectors from the filtered change areas.\n    var vectors = filteredChange.reduceToVectors({\n      reducer: ee.Reducer.countEvery(),\n      geometry: study_geometry,\n      scale: 30,\n      maxPixels: 1e13\n    });\n\n    // Extract centroids of the vectors.\n    var centroids = vectors.map(function(feature) {\n      return feature.geometry().centroid();\n    });\n\n    // Add vectors and centroids to their respective dictionaries.\n    changeLayersDict[year] = filteredChange;\n    centroidLayersDict[year] = centroids;\n  }\n  return {changeLayers: changeLayersDict, centroidLayers: centroidLayersDict};\n}\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Apply the function and add the centroid layers to the map.\nvar results = compareFilterAndExtractCentroids(savi_2017_2023, 2017, 2023, 100);\n\n// Access the centroid layers for further use.\nvar centroidLayers = results.centroidLayers;\n\n// Example: Add the centroid layers for specific years to the map.\nMap.addLayer(centroidLayers[2017], {color: 'yellow'}, 'Centroids 2017-2018');\nMap.addLayer(centroidLayers[2018], {color: 'yellow'}, 'Centroids 2018-2019');\nMap.addLayer(centroidLayers[2019], {color: 'yellow'}, 'Centroids 2019-2020');\nMap.addLayer(centroidLayers[2020], {color: 'yellow'}, 'Centroids 2020-2021');\nMap.addLayer(centroidLayers[2021], {color: 'yellow'}, 'Centroids 2021-2022');\nMap.addLayer(centroidLayers[2022], {color: 'yellow'}, 'Centroids 2022-2023');\n\n// ---------------------------------------------------------------------------------\n// End of part3\n// ---------------------------------------------------------------------------------\n\n\n\nIn part 3 we get a series of target points, but some desert variations and possibly Palestinian land will also be included. And it’s hard to tell who exactly the bare land belongs to. Therefore we try to capture features that are imperceptible to the human eye through machine learning.\nPalestinian-Israeli architectural complexes vary greatly. The current complex corresponds to bare land on historical satellite images. We attempted to guide the classification of bare land by classifying building groups.\n// ---------------------------------------------------------------------------------\n// Beginning of part4\n// Developed by Yilan Bu \n// Unreflected workload includes attempts at various classification orders and methods\n// ---------------------------------------------------------------------------------\n\n\n\n// Pre-Processing\n\n// Calculate GLCM\nvar glcm=sentinel.toUint16().select('B8').glcmTexture({size: 4})\n\n// Calculate NDWI\nvar ndwi=sentinel.normalizedDifference(['B3','B8'])\n                  .select(['nd'],['ndwi']);\n                  \n// Calculate NDVI                 \nvar ndvi=sentinel.normalizedDifference(['B8','B4'])\n                  .select(['nd'],['ndvi']);\n\n// Calculate NDBI                 \nvar ndbi=sentinel.normalizedDifference(['B11','B8'])\n                  .select(['nd'],['ndbi']);\n                  \n// Clip the map\nvar westbankborder = sentinel.clip(westbank);\n\n// Update the mask\nvar westbank_image= westbankborder\n                  .updateMask(ndwi.lt(0.3))\n                  .updateMask(ndvi.lt(0.2))\n                  .updateMask(ndbi.gt(0.1))\n                  .addBands(glcm)\n                  .addBands(ndbi)\n                  .select(bands);\n                  \n// Display the results\nMap.centerObject(westbank, 8);  // Center the map on the certain area with an appropriate zoom level\nMap.addLayer(westbank_image, {bands: ['B4', 'B3', 'B2'], max: 2000}, 'westbankborder');\nThen, we manually annotated Israeli and Palestinian building clusters. To enhance precision, we also marked desert areas due to the difficulty in distinguishing them from buildings using the NDVI and NDBI.\nTherfore, we divided three classes:\n\nClass 1: Israel building clusters\nClass 2: Palestinian building clusters\nClass3: Desert areas\n\n// Generating Labeled Data\n\n// Take random samples of points from within these polygons\n\n// Take points in each polygon\nvar points_in_Israeli = mergedAreas1235.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 250)\n  .map(function(point) {\n    return point.set({'class': 0});\n });\n}).flatten();\n\nvar points_outside_Israeli = Outside_Israeli.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 400)\n  .map(function(point) {\n    return point.set({'class': 1});\n });\n}).flatten();\n\nvar desert_points = Desert_Areas.map(function(feature) {\n  return ee.FeatureCollection.randomPoints(feature.geometry(), 1080)\n  .map(function(point) {\n    return point.set({'class': 2});\n  });\n}).flatten();\n\n// Create one feature collection\nvar Israeli_points = ee.FeatureCollection([points_in_Israeli,\n                                  points_outside_Israeli,\n                                  desert_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();    \n                                  \n// Create a sample dataset from the merged marked area\nvar split=0.7\nvar training_samples = Israeli_points.filter(ee.Filter.lt('random', split));\nvar validation_sample = Israeli_points.filter(ee.Filter.gte('random', split));\n\n// Obtain training set\nvar training = westbank_image.sampleRegions({\n  collection: training_samples,\n  properties: ['class'],\n  scale: 10,\n});\n\n// Obtain validation set\nvar validation = westbank_image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// Select classification features and training classifiers\nvar model = ee.Classifier.smileRandomForest(500)\n                         .train(training, 'class');\n\nprint('Training class 0:', training_samples.filter(ee.Filter.eq('class', 0)).size());\nprint('Training class 1:', training_samples.filter(ee.Filter.eq('class', 1)).size());\nprint('Training class 2:', training_samples.filter(ee.Filter.eq('class', 2)).size());\nprint('Validation class 0:', validation_sample.filter(ee.Filter.eq('class', 0)).size());\nprint('Validation class 1:', validation_sample.filter(ee.Filter.eq('class', 1)).size());\nprint('Validation class 2:', validation_sample.filter(ee.Filter.eq('class', 2)).size());\n\n// Make prediction\nvar prediction = westbank_image.classify(model);\n\n// Select Israeli architectural complex\nvar Israeli_prediction=prediction.updateMask(prediction.eq(0));\n\n// Add layer\nMap.addLayer(Israeli_prediction, {palette:'red'}, 'Predicted Israeli Architectural Complex');\n\n// Validate the model with the validation dataset and classify the samples\nvar validated = validation.classify(model);\n\n// Compute the error matrix for the validation results to assess the accuracy\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\n// Print the confusion matrix to the console for evaluation\nprint('Confusion Matrix ', testAccuracy);\n\n// ---------------------------------------------------------------------------------\n// End of part4\n// ---------------------------------------------------------------------------------\nThe model’s accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.\nHowever, during the annotation and recognition process, we made an unexpected discovery that most newly developed lands were developed by Israel, and it would be almost impossible for Palestine to engage in new land excavation.\nTherefore, we did not use the part4 results for filtering, and we believed that the points obtained by part3 were sufficient for users. These points include only Israel and the desert, with the desert concentrated on the east side and easily distinguishable by the human eye. Applying part4 filtering may result in correct objects being excluded, which is less acceptable than deserts being included.\n\n\n\nThis code segment primarily establishes and configures a user interface (UI) panel for interactively displaying and managing map layers. The panel allows users to select from various map layers such as “West Bank Border”, “SAVI”, “Change Detection”, and “New Israeli Settlement Locations” through a dropdown menu. The interface updates the displayed map layers and associated information based on the user’s selection.\nAdditionally, the panel includes a slider for selecting years, which influences the displayed content of map layers, such as SAVI indices or change detection results. Moreover, the panel supports the display of additional control elements like information buttons and year labels, which are displayed conditionally depending on the currently selected map layer.\nThese controls are dynamically managed through written functions, such as showing and hiding specific controls, updating map layers, or handling map click events, thereby enhancing user interaction.\n\n\n\nUI Panel\n\n\n// ---------------------------------------------------------------------------------\n// Beginning of part5\n// Developed by Junrun Chen \n// Beautified by Xiaolin Liu\n// ---------------------------------------------------------------------------------\n\n//////////////////////////////////////////////////////////////////////////////////\n// create UI Panel\nvar panel = ui.Panel();\npanel.style().set({\n  width: '400px',\n  padding: '8px'\n});\nui.root.insert(0, panel);\n\n// Layer select change event handler\nvar layerSelect = ui.Select({\n  items: ['West Bank Border', 'SAVI', 'Change detection', 'Predicted Israeli Architectural Complex','New Israeli Building Clusters'],\n  onChange: handleLayerChange\n});\n\n// Function to handle layer changes\nfunction handleLayerChange(selected) {\n  currentLayer = selected;\n  var showSlider = selected === 'SAVI' || selected === 'Change detection'|| selected === 'New Israeli Building Clusters';\n  var showChart = selected === 'SAVI'; // Only show chart for SAVI layer\n  var showLabels = selected === 'SAVI' || selected === 'Change detection'|| selected === 'New Israeli Building Clusters';\n  var showInfoButton = selected === 'Predicted Israeli Architectural Complex';\n\n  // Update the visibility of UI components\n  //toggleInfoButton.style().set('shown', showInfoButton);\n  //updateLabelPanelVisibility(showLabels);\n  yearSlider.style().set('shown', showSlider);\n  yearLabel.style().set('shown', showSlider);\n  \n  // Reset and update map layers\n  Map.layers().reset();\n  updateMapLayers(selected);\n\n  // Update the display of charts\n  if (showChart) {\n    updateChart(yearSlider.getValue());\n  } else {\n    clearChart();\n  }\n\n  // Display the confusion matrix if required\n  if (selected === 'West Bank Border'){\n    \n    // New Israeli Settlement Identification\n    var boldText = ui.Label({\n      value: 'New Israeli Settlement Identification In The West Bank',\n      style: {fontWeight: 'bold', fontSize: '14px'}\n    });\n    panel.add(boldText); \n\n    // Description 1\n    var description1 = ui.Label({\n      value: 'Users can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. Users are free to explore what is happening at each step.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    var link = ui.Label({\n      value: 'For more information:  https://www.aljazeera.com/news/2021/5/18/mapping-israeli-occupation-gaza-palestine',\n      style:{fontSize:'12px',color: '000129'}\n    })\n    panel.add(link);\n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Instructions:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var instruction = ui.Label({\n      value:'We can toggle between layers using the “Layers” button in the top right corner of the map. Blue represents the Palestinian-controlled areas, red represents the Palestinian-Israeli controlled areas, and the rest of the West Bank is under full Israeli control.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var note = ui.Label({\n      value:'We can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n    \n    currentWidgets.push(boldText,description1,link,title1,instruction,note);\n  }\n\n  if (selected === 'Predicted Israeli Architectural Complex'){\n      var errorMatrix = validated.errorMatrix('class', 'classification');\n      displayConfusionMatrix(errorMatrix);\n  }\n  \n  if (selected === 'SAVI'){\n    \n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'Israeli outposts and early settlements often appear as bare land. Based on this characteristic, SAVI can efficiently and accurately identify target lands, outperforming machine learning in both speed and accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    // Note\n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'By dragging the slider, users can view the identification results for different years. Although not the direct purpose of this application, we also provide visualization of the SAVI index to help users understand the trends in bare land changes and the proportions in different years.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var description = ui.Label({\n      value:'The image is presented in red and black, with red representing our target identified lands. After zooming and moving the image, users can see some clear lines and shapes emerging. Lines indicate unhardened roads, and shapes represent bare land. These likely correspond to the early Israeli settlements.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description);\n    \n    currentWidgets.push(title1,Purpose,title2,instruction,description);\n  }\n  \n  if (selected === 'Change detection'){\n    \n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'SAVI detection results include existing bare land and extensive permanent deserts. The application aims to identify new settlements, thus necessitating the exclusion of these perennially bare areas. By calculating the difference between SAVI images from consecutive years, we can isolate the changed areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n\n    panel.add(toggleRegionButton);  \n    currentWidgets.push(title1,Purpose,title2,instruction,toggleRegionButton);\n  }\n\n  if (selected === 'Predicted Israeli Architectural Complex'){\n    \n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value: 'After identifying the coordinates of all target type land, it is necessary to distinguish land ownership. Directly labeling bare land is inefficient and challenging, so we utilize a novel approach using historical satellite images. While bare land in Israel lacks distinctive features, Israeli buildings significantly differ from those in Palestine. Historical images of locations with Israeli buildings will inevitably show bare land. By labeling and classifying these buildings, we can attribute the land to Israeli ownership.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var description1 = ui.Label({\n      value:'The image on the right, where red indicates the predicted Israeli building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);\n    \n    var description2 = ui.Label({\n      value:'The table on the left is the confusion matrix of the classification results. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description2);    \n    \n    var description3 = ui.Label({\n      value:'Class 1 is Israel building clusters. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description3);        \n\n    var description4 = ui.Label({\n      value:'Class 2 is Palestinian building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description4);        \n\n    var description5 = ui.Label({\n      value:'Class 3 is the desert areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description5);   \n    var description6 = ui.Label({\n      value:'The accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description6);   \n\n    currentWidgets.push(title1,Purpose,title2,description1,description2,description3,description4,description5,description6);\n  }\n  \n  if (selected === 'New Israeli Building Clusters'){\n\n    // Description 1\n    var description1 = ui.Label({\n      value:'We can use the slider on the upper left to switch between different years to view the distribution of recognition results. The left panel provides a visualization of the current year and the trend of changes to facilitate user data query.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Note:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var note = ui.Label({\n      value:'By filtering the shapes and areas within the change detection results, the application extracts the centroids of various geometric shapes corresponding to Israeli settlements established in different years. Given the broad span of years, users can observe that some settlements have developed into towns. Users can toggle between years to view the latest settlements or those that have been fully established. Due to limitations in the filtering logic, some desert changes and agricultural land transformations are not fully filtered out. In the future, new methods will be sought to optimize accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n\n    currentWidgets.push(description1,title1,note);\n  }\n}\n\n// Add controls to the panel\npanel.add(ui.Label('Layer Selector:', {fontWeight: 'bold'}));\npanel.widgets().set(1,layerSelect);\n\nvar currentWidgets = [];  // Array to store current widgets for easy removal\n\n// Create a slider to select the year\nvar yearSlider = ui.Slider({\n  min: 2017,\n  max: 2022,\n  value: 2018,\n  step: 1,\n  style: {stretch: 'horizontal', shown: false}\n});\nvar yearLabel = ui.Label('Chozen Year:', {fontWeight: 'bold', shown: false});\nyearLabel.setValue('Chozen Year: ' + yearSlider.getValue());\npanel.widgets().set(2,yearLabel);\npanel.widgets().set(3,yearSlider);\n\nvar currentLayer = '';\n\n// Create an info panel\nvar infoPanel = ui.Panel({\n  style: {\n    position: 'bottom-left',\n    width: '300px',\n    maxHeight: '400px',\n    padding: '8px',\n    backgroundColor: 'Black',\n    shown: false\n  }\n});\n\n// Create a button to toggle the display of information\nvar toggleInfoButton = ui.Button({\n  label: 'Show/Hide Information',\n  onClick: function() {\n    var shown = infoPanel.style().get('shown');\n    infoPanel.style().set('shown', !shown);\n  },\n  style: {\n    shown: false\n  }\n});\npanel.add(toggleInfoButton);\n\n\nconsole.log(diffImages);\n\nfunction countChanges(diffImage, geometry) {\n  var histogram = diffImage.reduceRegion({\n    reducer: ee.Reducer.frequencyHistogram(),\n    geometry: geometry,\n    scale: 30,\n    maxPixels: 1e9\n  }).get('SAVI');\n\n  return ee.Dictionary(histogram);\n}\n\nvar changeData = [];\n\nvar years = ['2017_2018', '2018_2019', '2019_2020', '2020_2021', '2021_2022', '2022_2023'];\nyears.forEach(function(year) {\n  var diffImage = diffImages.get(year);\n  var stats = countChanges(ee.Image(diffImage), study_area);\n  changeData.push(stats);\n});\n\nvar changeFc = ee.FeatureCollection(changeData.map(function(item, index) {\n  return ee.Feature(null, {\n    'year': years[index],\n    'increased': item.getNumber('1'),\n    'decreasedUnchanged': item.getNumber('0')\n  });\n}));\n\n\nvar changeChart = ui.Chart.feature.byFeature({\n  features: changeFc,\n  xProperty: 'year',\n  yProperties: ['increased', 'decreasedUnchanged']\n}).setOptions({\n  title: 'Yearly SAVI Changes',\n  vAxis: {title: 'Pixel Count'},\n  hAxis: {title: 'Year'},\n  lineWidth: 1,\n  series: {\n    0: {color: 'green'},  \n    1: {color: 'red'}     \n  }\n});\nvar saviregion\n// Start with study_area as the default active region\nvar activeGeometry = study_area;\n// Button to toggle between study_area and saviregion\nvar toggleRegionButton = ui.Button('Switch Area');  // Initial label setup\n\ntoggleRegionButton.onClick(function() {\n  // Toggle the active geometry\n  handleLayerChange(currentLayer);\n  activeGeometry = (activeGeometry === study_area) ? saviregion : study_area;\n  \n  // Update the label of the button\n  var newLabel = 'Active Geometry: ' + (activeGeometry === study_area ? 'Default Area' : 'Custom Region');\n  toggleRegionButton.setLabel(newLabel);\n\n\n});\n\n// Global variable to store the reference of the clicked point layer\nvar clickedPointLayer = null;\n\nfunction mapClickHandler(coords) {\n  if (currentLayer === 'Change detection') {\n  var point = ee.Geometry.Point([coords.lon, coords.lat]);\n  // Adjust this buffer radius as needed or use it directly for point-based analysis\n  saviregion = point.buffer(1000);  // 1000 meter buffer around the clicked point\n\n  // Clear previous clicked point from the map (optional)\n  if (clickedPointLayer !== null) {\n    Map.layers().remove(clickedPointLayer);\n  }\n  // Define the style for the point\n  var pointStyle = {color: 'green', fillColor: '00000000'};\n\n  // Add the point to the map with style\n  clickedPointLayer = Map.addLayer(point, pointStyle, 'Clicked Point');\n\n  // Additional actions based on current layer type\n\n  }\n}\n\n// Register map click event\nMap.onClick(mapClickHandler);\n\nfunction resetYearselector() {\n      panel.remove(yearLabel);\n      panel.remove(yearSlider);\n      panel.add(yearLabel);\n      panel.add(yearSlider);\n}\n\nvar currentLegend = null;\nvar diffimage\n\n\nfunction addLegendWithAnnotations(options,clearExisting) {\n  var title = options.title;\n  var palette = options.palette;\n  var annotations = options.annotations;\n  var position = options.position;\n\n  if (clearExisting && currentLegend) {\n    Map.remove(currentLegend);\n    currentLegend = null;\n  }\n\n  var legend = ui.Panel({\n    style: {\n      position: position,\n      padding: '8px',\n      backgroundColor: 'white'\n    }\n  });\n  \n  var legendTitle = ui.Label({\n    value: title,\n    style:{fontWeight: 'bold'}\n  });\n  legend.add(legendTitle);\n  \n  var colorBlocksPanel = ui.Panel({\n    layout: ui.Panel.Layout.flow('vertical')\n  });\n  \n  var lineHeight = 24; // Increased line height for better readability\n  var totalHeight = palette.length * lineHeight; // Total height of the legend\n  \n  colorBlocksPanel.style().set('height', totalHeight + 'px'); // Set the height of the color block panel\n  \n  palette.forEach(function(color, index) {\n    var colorBlockPanel = ui.Panel({\n      layout: ui.Panel.Layout.flow('horizontal') // Each color block and annotation on the same line\n    });\n    \n    var colorBlock = ui.Label('', {\n      backgroundColor: color,\n      padding: '6px',\n      margin: '4px 4px 0 0', // Increase right margin\n      width: '20px', // Increase width\n      height: '20px' // Increase height\n    });\n    colorBlockPanel.add(colorBlock);\n    \n    var annotationLabel = ui.Label(annotations[index], {\n      margin: '0' // Remove unnecessary margins\n    });\n    colorBlockPanel.add(annotationLabel);\n    \n    colorBlocksPanel.add(colorBlockPanel);\n  });\n  \n  legend.add(colorBlocksPanel);\n  currentLegend = legend;\n  Map.add(legend);\n}\n\n// Function used to update the map display based on the selected layer\nfunction updateMapLayers(selected) {\n  Map.setOptions(\"satellite\");\n  var darkLayer = ee.Image.constant(0).visualize({palette: ['000000'], opacity: 0.5}); \n  Map.addLayer(darkLayer, {}, 'Dark Layer'); \n  Map.setZoom(13);\n  removeChart();\n  var endYear = yearSlider.getValue() + 1\n  var year = yearSlider.getValue();\n  // Clear specific widgets related to the confusion matrix\n        currentWidgets.forEach(function(widget) {\n            panel.remove(widget);\n        });\n        currentWidgets = [];  // Reset the widget tracker\n  switch (selected) {\n    case 'West Bank Border':\n      addLegendWithAnnotations({\n      title: 'West Bank Border',\n      palette: ['07C7F2','F2055C','260B10'],\n      annotations: ['Palestinian-controlled','Palestinian-Israeli controlled','Israeli-controlled'],\n      position: 'bottom-right'\n      }, true);\n      Map.setCenter(35.5, 32.1, 9)\n      Map.addLayer(westbank, {color:'260B10'}, 'West Bank Border',1,0.9);\n      Map.addLayer(areaB, {color:'F2055C'}, 'Area B',1,0.8);\n      Map.addLayer(areaA, {color:'07C7F2'}, 'Area A',1,0.8);\n      break;\n    case 'SAVI':\n      //clearChart();\n      addLegendWithAnnotations({\n      title: 'SAVI',\n      palette: ['F20519','260B10'],\n      annotations: ['Bare Land', 'Other'],\n      position: 'bottom-right'\n      }, true);\n      resetYearselector();\n      var savi_image = ee.Image(savi_2017_2023.get(yearSlider.getValue().toString()));\n      Map.addLayer(savi_image, visdiff, 'SAVI_' + yearSlider.getValue().toString()+ '_'+ endYear); \n      break;\n    case 'Change detection':\n      //clearChart();\n      addLegendWithAnnotations({\n      title: 'Difference',\n      palette: ['F20519', '260B10'],\n      annotations: ['Changed Area', 'Unchanged Area'],\n      position: 'bottom-right'\n      }, true);\n      resetYearselector();\n      var startYear = yearSlider.getValue(); \n      panel.widgets().forEach(function(widget) {\n        if (widget instanceof ui.Label && widget.getValue() === 'Please select a year after 2017 for the end year to see the changes found this year.') {\n          panel.remove(widget);\n        }\n        \n      });\n      var endYear = startYear + 1; \n      var diffKey = startYear.toString() + '_' + endYear.toString();\n      var diff_image = ee.Image(diffImages.get(diffKey));\n      Map.addLayer(diff_image, visdiff, 'Difference_' + diffKey); \n      diffimage = diff_image;\n      \n      break;\n    case 'Predicted Israeli Architectural Complex':\n      addLegendWithAnnotations({\n      title: 'Predicted Israeli Architectural Complex',\n      palette: ['5821A6'],\n      annotations: ['Predicted Israeli Building'],\n      position: 'bottom-right'\n      }, true);\n      Map.addLayer(westbank, {palette: '260B10'}, 'West Bank Border',1,0.8);\n      Map.addLayer(Israeli_prediction, {palette: '5821A6'}, 'Predicted Israeli Architectural Complex',true); // 在这里添加预测建筑图层的图例\n      break;\n    case 'New Israeli Building Clusters':\n      addLegendWithAnnotations({\n      title: 'New Israeli Building Clusters',\n      palette: ['F2B33D'],\n      annotations: ['Centroids'],\n      position: 'bottom-right'\n      }, true);\n      resetYearselector();\n      Map.addLayer(centroidLayers[yearSlider.getValue()], {color: 'F2B33D'}, 'Centroids' + yearSlider.getValue() +\"-\"+ endYear);\n      break;\n  }\n\n}\n\nui.root.add(infoPanel);\nvar errorMatrix = validated.errorMatrix('class', 'classification');\n\n// Default display of the initial year's layer\nupdateMapLayers('West Bank Border');\nlayerSelect.setValue('West Bank Border', true);\n\n// Function to update or clear chart based on current layer\n// Calculate the number of pixels with SAVI=1 for each year from 2017 to 2023 and add a line chart to the existing panel\n\nvar savedChart;\nfunction calculateSAVI1Counts() {\n  var counts = []; // Array to store counts for each year\n\n  // Iterate through each year\n  for (var year = 2017; year &lt;= 2023; year++) {\n    var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n\n    // Create a mask for SAVI values equal to 1\n    var mask1 = selectedYearImage.eq(1);\n\n    // Apply the mask\n    var image1 = selectedYearImage.updateMask(mask1);\n\n    // Calculate the number of pixels with SAVI value equal to 1\n    var countPixels1 = image1.reduceRegion({\n      reducer: ee.Reducer.count(),\n      geometry: activeGeometry,\n      scale: 30,\n      maxPixels: 1e9\n    });\n\n    // Add each year's result to the array\n    counts.push({\n      'year': year,\n      'count': countPixels1.get('SAVI')\n    });\n  }\n\n  // Convert the results array to a FeatureCollection\n  var countFeatures = ee.FeatureCollection(counts.map(function(item) {\n    return ee.Feature(null, item);\n  }));\n\n  // Create a line chart\n  var countChart = ui.Chart.feature.byFeature({\n    features: countFeatures,\n    xProperty: 'year',\n    yProperties: ['count']\n  })\n  .setOptions({\n    title: 'SAVI = 1 Pixel Counts from 2017 to 2023',\n    hAxis: {title: 'Year'},\n    vAxis: {title: 'Count of Pixels'},\n    lineWidth: 1,\n    pointSize: 3\n  });\n\n  // Add the chart to the existing panel\n  panel.widgets().add(countChart);\n  savedChart = countChart;\n}\n\n// Function to remove the chart\nfunction removeChart() {\n  if (savedChart) {\n    panel.widgets().remove(savedChart);\n    savedChart = null; // Clear the reference, indicating that there is currently no chart\n  }\n}\n\nfunction updateChart(year) {\n  removeChart();\n  var selectedYearImage = ee.Image(savi_2017_2023.get(year.toString()));\n  // Create masks for SAVI values 0 and 1\n  var mask0 = selectedYearImage.eq(0);\n  var mask1 = selectedYearImage.eq(1);\n\n  // Apply masks to the original image\n  var image0 = selectedYearImage.updateMask(mask0);\n  var image1 = selectedYearImage.updateMask(mask1);\n\n  // Generating a histogram for SAVI values\n  var histogramChart = ui.Chart.image.histogram({\n    image: ee.Image.cat([image0.select('SAVI'), image1.select('SAVI')]),\n    region: activeGeometry,\n    scale: 30,\n    minBucketWidth: 0.001,  // Each bucket corresponds exactly to one SAVI value\n  }).setOptions({\n    title: year + ' SAVI Value Distribution',\n    vAxis: {title: 'Pixel Count'},\n    hAxis: {title: 'SAVI', ticks: [{v:0, f:'0'}, {v:1, f:'1'}]}, // Explicitly show only 0 and 1\n    series: {\n      0: {color: 'blue', label: 'SAVI = 0'},  // Color and label for SAVI value 0\n      1: {color: 'red', label: 'SAVI = 1'}    // Color and label for SAVI value 1\n    },\n    bar: {groupWidth: \"20%\"}  // Adjust the width of the bars\n  });\n\n  // Count and print the number of pixels with SAVI = 1\n  var countPixels1 = image1.reduceRegion({\n    reducer: ee.Reducer.count(),\n    geometry: activeGeometry,\n    scale: 30,\n    maxPixels: 1e9\n  });\n\n  // Check if there is already a chart at the expected position in the panel and replace it or add the new chart.\n  if (panel.widgets().length() &gt; 2) {\n    panel.widgets().set(2, histogramChart); // Replace the existing chart\n  } else {\n    panel.widgets().insert(2, histogramChart); // Add the chart if not already present\n  }\n  //panel.widgets().remove(countChart);\n  calculateSAVI1Counts();\n}\n\n// Function to clear the chart\nfunction clearChart() {\n  if (panel.widgets().length() &gt; 2) {\n    panel.remove(panel.widgets().get(2));  // Remove the chart widget\n  }\n}\n\n// Slider event handling\nyearSlider.onSlide(function(value) {\n  \n  yearLabel.setValue('Chozen Year: ' + value);\n  // Retrieve the differential image for the selected year and the next year.\n\n  handleLayerChange(currentLayer);\n  \n  // If the current layer requires a specific description, it is handled here\n  if (currentLayer === 'West Bank Border') {\n    updateDescriptionForWestBankBorder();\n  } else if (currentLayer === 'SAVI') {\n    updateChart(value); // Update chart only if SAVI is currently selected\n    updateDescriptionForSAVI();\n  } else if (currentLayer === 'Change detection') {\n\n    updatePieChart(diffimage, activeGeometry);\n    //updateChangeChart(diffImages, activeGeometry);\n    //panel.widgets().set(8, diffchart);\n    //updateLineChart(diffImages, activeGeometry);\n    updateDescriptionForChangeDetection();\n    if(!layerSelect){panel.add(layerSelect);}\n  } else if (currentLayer === 'Predicted Israeli Architectural Complex') {\n    updateDescriptionForPredictedIsraeliArchitecturalComplex();\n  } else if (currentLayer === 'New Israeli Building Clusters') {\n    updateDescriptionForCenters();\n    displayCentroidScatter(results.centroidLayers, yearSlider.getValue());\n  }\n\n});\n\n// Helper functions to manage descriptions for different layers\nfunction updateDescriptionForWestBankBorder() {\n  clearDescriptions();\n    // New Israeli Settlement Identification\n    var boldText = ui.Label({\n      value: 'New Israeli Settlement Identification In The West Bank',\n      style: {fontWeight: 'bold', fontSize: '14px'}\n    });\n    panel.add(boldText); \n\n    // Description 1\n    var description1 = ui.Label({\n      value: 'Users can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. Users are free to explore what is happening at each step.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    var link = ui.Label({\n      value: 'For more information:  https://www.aljazeera.com/news/2021/5/18/mapping-israeli-occupation-gaza-palestine',\n      style:{fontSize:'12px',color: '000129'}\n    })\n    panel.add(link);\n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Instructions:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var instruction = ui.Label({\n      value:'We can toggle between layers using the “Layers” button in the top right corner of the map. Blue represents the Palestinian-controlled areas, red represents the Palestinian-Israeli controlled areas, and the rest of the West Bank is under full Israeli control.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var note = ui.Label({\n      value:'We can explore different contents through the tabs on the upper left, and detailed descriptions will be presented on the corresponding pages. In addition to directly querying new Israeli settlements, the app also visualizes the entire analysis process. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n    \n    currentWidgets.push(boldText,description1,link,title1,instruction,note);\n}\n\nfunction updateDescriptionForSAVI() {\n  clearDescriptions();\n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'Israeli outposts and early settlements often appear as bare land. Based on this characteristic, SAVI can efficiently and accurately identify target lands, outperforming machine learning in both speed and accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    // Note\n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'By dragging the slider, users can view the identification results for different years. Although not the direct purpose of this application, we also provide visualization of the SAVI index to help users understand the trends in bare land changes and the proportions in different years.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n    \n    var description = ui.Label({\n      value:'The image is presented in red and black, with red representing our target identified lands. After zooming and moving the image, users can see some clear lines and shapes emerging. Lines indicate unhardened roads, and shapes represent bare land. These likely correspond to the early Israeli settlements.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description);\n    \n    currentWidgets.push(title1,Purpose,title2,instruction,description);\n}\n\nfunction updateDescriptionForChangeDetection() {\n  clearDescriptions();\n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value:'SAVI detection results include existing bare land and extensive permanent deserts. The application aims to identify new settlements, thus necessitating the exclusion of these perennially bare areas. By calculating the difference between SAVI images from consecutive years, we can isolate the changed areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var instruction = ui.Label({\n      value:'We can zoom in to see if there are any new roads under construction. If we notice a continuous red line, it is highly likely that this road is newly built.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(instruction);\n\n    panel.add(toggleRegionButton);  \n    currentWidgets.push(title1,Purpose,title2,instruction,toggleRegionButton);\n}\n\nfunction updateDescriptionForPredictedIsraeliArchitecturalComplex() {\n  clearDescriptions();\n    var title1 = ui.Label({\n      value: 'Purpose:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var Purpose = ui.Label({\n      value: 'After identifying the coordinates of all target type land, it is necessary to distinguish land ownership. Directly labeling bare land is inefficient and challenging, so we utilize a novel approach using historical satellite images. While bare land in Israel lacks distinctive features, Israeli buildings significantly differ from those in Palestine. Historical images of locations with Israeli buildings will inevitably show bare land. By labeling and classifying these buildings, we can attribute the land to Israeli ownership.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(Purpose);\n    \n    var title2 = ui.Label({\n      value: 'Instructions: ',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title2);\n    \n    var description1 = ui.Label({\n      value:'The image on the right, where red indicates the predicted Israeli building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);\n    \n    var description2 = ui.Label({\n      value:'The table on the left is the confusion matrix of the classification results. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description2);    \n    \n    var description3 = ui.Label({\n      value:'Class 1 is Israel building clusters. ',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description3);        \n\n    var description4 = ui.Label({\n      value:'Class 2 is Palestinian building clusters.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description4);        \n\n    var description5 = ui.Label({\n      value:'Class 3 is the desert areas.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description5);   \n    var description6 = ui.Label({\n      value:'The accuracy is quite high, at around 90%. In detail, the model performs best when predicting desert regions, followed by Israeli building clusters. Confusion primarily occurs between Israeli and Palestinian building clusters, as well as between Israeli building clusters and desert regions.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description6);   \n\n    currentWidgets.push(title1,Purpose,title2,description1,description2,description3,description4,description5,description6);\n}\n\nfunction updateDescriptionForCenters() {\n  clearDescriptions();\n\n    // Description 1\n    var description1 = ui.Label({\n      value:'We can use the slider on the upper left to switch between different years to view the distribution of recognition results. The left panel provides a visualization of the current year and the trend of changes to facilitate user data query.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(description1);  \n    \n    // Instructions\n    var title1 = ui.Label({\n      value: 'Note:',\n      style: {fontWeight: 'bold', fontSize: '12px'}  \n    });\n    panel.add(title1);\n    \n    var note = ui.Label({\n      value:'By filtering the shapes and areas within the change detection results, the application extracts the centroids of various geometric shapes corresponding to Israeli settlements established in different years. Given the broad span of years, users can observe that some settlements have developed into towns. Users can toggle between years to view the latest settlements or those that have been fully established. Due to limitations in the filtering logic, some desert changes and agricultural land transformations are not fully filtered out. In the future, new methods will be sought to optimize accuracy.',\n      style:{fontSize:'12px'}\n    });\n    panel.add(note);\n\n    currentWidgets.push(description1,title1,note);\n}\n\n// Function to clear previously added descriptions\nfunction clearDescriptions() {\n  currentWidgets.forEach(function(widget) {\n    panel.remove(widget);\n  });\n  currentWidgets = [];  // Reset the widget tracker\n}\n\n// Function to display confusion matrix\nfunction displayConfusionMatrix(errorMatrix) {\n  // Clear previously added widgets from the panel\n  currentWidgets.forEach(function(widget) {\n    panel.remove(widget);\n  });\n  currentWidgets = [];  // Reset the array after clearing\n\n  var matrixArray = errorMatrix.array();\n  // Define custom labels for the matrix categories\n  var labels = ['Israel', 'Palestine', 'Joint Administration'];\n\n  var matrixChart = ui.Chart.array.values({\n    array: matrixArray,\n    axis: 0,\n    xLabels: labels  // Use descriptive labels for the x-axis\n  }).setChartType('Table').setOptions({\n    title: 'Confusion Matrix',\n    hAxis: {\n      title: 'Predicted Label',\n      ticks: labels.map(function(label, index) { return {v: index, f: label}; })  // Custom tick labels\n    },\n    vAxis: {\n      title: 'Actual Label',\n      ticks: labels.map(function(label, index) { return {v: index, f: label}; })  // Custom tick labels\n    },\n    colors: ['yellow', 'red', 'green']\n  });\n\n  panel.add(matrixChart);  // Display the chart\n  currentWidgets.push(matrixChart);  // Store references to remove later\n}\n\nfunction updatePieChart(diffImage, geometry) {\n  currentWidgets.forEach(function(widget) {\n        panel.remove(widget);\n    });\n  currentWidgets = [];  // Reset the array after clearing\n  var stats = diffImage.reduceRegion({\n    reducer: ee.Reducer.frequencyHistogram(),\n    geometry: geometry,\n    scale: 30,\n    maxPixels: 1e9\n  });\n  console.log(diffimage);\n  // Asynchronously evaluate the histogram calculation\n  stats.evaluate(function(result) {\n    if (result.SAVI) {\n      var data = [['Change Type', 'Area']];\n      var totalIncreased = result.SAVI['1'] || 0; // Ensure default if undefined\n      var totalDecreasedUnchanged = result.SAVI['0'] || 0; // Ensure default if undefined\n      data.push(['Increased', totalIncreased]);\n      data.push(['Decreased/Unchanged', totalDecreasedUnchanged]);\n\n      // Create the chart directly from the array\n      var chart = ui.Chart(data)\n        .setChartType('PieChart')\n        .setOptions({\n          title: 'Proportion of SAVI Change' + yearSlider.getValue(),\n          slices: {\n            0: {color: 'red'},  // Decreased or unchanged\n            1: {color: 'green'} // Increased\n          },\n          pieSliceText: 'percentage',\n          is3D: true,\n          fontSize: 12\n        });\n      // Replace or add the chart in the UI panel\n      if (panel.widgets().length() &gt; 2) {\n        panel.widgets().set(7, chart); // Assume the second position for the chart\n        //panel.widgets().set(8,changeChart);\n        currentWidgets.push(chart);\n      }\n    } else {\n      console.log(\"No data available for the specified range.\");\n    }\n  });\n\n  updateChangeChart(diffImages, activeGeometry);\n  //console.log(panel);\n}\n\nvar diffchart\n// Function to update the line chart for SAVI changes over the years\nfunction updateChangeChart(diffImages, geometry) {\n  // Collect data for each year and compute changes\n  var changeData = ee.List([]);\n  var years = ['2017_2018', '2018_2019', '2019_2020', '2020_2021', '2021_2022', '2022_2023'];\n\n  years.forEach(function(year) {\n    var diffImage = ee.Image(diffImages.get(year));\n    var stats = diffImage.reduceRegion({\n      reducer: ee.Reducer.frequencyHistogram(),\n      geometry: geometry,\n      scale: 30,\n      maxPixels: 1e9\n    }).get('SAVI');\n\n    var data = ee.Dictionary(stats);\n    var increased = data.getNumber('1').getInfo();\n    var decreasedUnchanged = data.getNumber('0').getInfo();\n    \n    changeData = changeData.add(ee.Feature(null, {\n      'year': year,\n      'increased': increased,\n      'decreasedUnchanged': decreasedUnchanged\n    }));\n  });\n\n  // Convert list to feature collection for charting\n  var changeFc = ee.FeatureCollection(changeData);\n\n  // Create and display the chart\n  var changeChart = ui.Chart.feature.byFeature({\n    features: changeFc,\n    xProperty: 'year',\n    yProperties: ['increased', 'decreasedUnchanged']\n  }).setOptions({\n    title: 'Yearly Difference',\n    vAxis: {title: 'Pixel Count'},\n    hAxis: {title: 'Year'},\n    lineWidth: 1,\n    series: {\n      0: {color: 'green'},  // SAVI increased\n      1: {color: 'red'}     // SAVI decreased or unchanged\n    }\n  });\n  //diffchart = changeChart;\n\n  // Check if a chart already exists in the UI, replace or add\n \n    panel.widgets().add(changeChart);\n    currentWidgets.push(diffchart);\n\n  //console.log(panel);\n}\n\nfunction displayChangeHistogram(yearlyImages, year, geometry) {\n    var currentImage = ee.Image(yearlyImages.get(year.toString()));\n    var nextImage = ee.Image(yearlyImages.get((parseInt(year) + 1).toString()));\n    \n    var transitionToRed = currentImage.gte(0.2).and(nextImage.lt(0.2));\n    var filteredChange = filterSmallPatches(transitionToRed, 100);\n    \n    var areaHistogram = filteredChange.reduceRegion({\n        reducer: ee.Reducer.frequencyHistogram(),\n        geometry: geometry,\n        scale: 30,\n        maxPixels: 1e9\n    });\n\n    areaHistogram.evaluate(function(result) {\n        var chart = ui.Chart.array.values({\n            array: Object.values(result.SAVI),\n            axis: 0,\n            xLabels: Object.keys(result.SAVI)\n        }).setOptions({\n            title: 'Distribution of Change Areas for ' + year,\n            vAxis: {title: 'Frequency'},\n            hAxis: {title: 'Area Size (pixels)'},\n            series: {0: {color: 'red'}}\n        });\n\n        // Display chart\n        if (panel.widgets().length() &gt; 5) {\n            panel.widgets().set(5, chart);\n        } else {\n            panel.add(chart);\n        }\n    });\n}\n\nconsole.log(centroidLayers);\n\nfunction displayCentroidScatter(centroidLayers, year) {\n    var centroids = centroidLayers[year];\n    \n    var centroidChart = ui.Chart.feature.byFeature(centroids, 'longitude', ['latitude'])\n        .setChartType('ScatterChart')\n        .setOptions({\n            title: 'Centroids of Changed Areas in ' + year,\n            hAxis: {title: 'Longitude'},\n            vAxis: {title: 'Latitude'},\n            pointSize: 5,\n            colors: ['yellow']  // Points in yellow\n        });\n\n    // Display chart\n    if (panel.widgets().length() &gt; 2) {\n        panel.widgets().add(centroidChart);\n    } else {\n        panel.add(centroidChart);\n    }\n    countAndChartCentroids(centroidLayers);\n}\n\n\n//Create an information panel to display feature attributes, and set it to not be displayed initially\nvar infoPanel = ui.Panel({\n   style: {\n     position: 'bottom-left',\n     width: '300px',\n     maxHeight: '400px',\n     padding: '8px',\n     backgroundColor: 'white',\n     shown: false //Initially set to not show\n   }\n});\n\n//Create a switch button to control the display and hiding of the information panel\nvar infotoggleButton = ui.Button({\n   label: 'Show/hide Region information',\n   onClick: function() {\n     //Switch the display state of the information panel\n     var shown = infoPanel.style().get('shown');\n     infoPanel.style().set('shown', !shown);\n     infotoggleButton.setLabel(shown ? 'Show Region info' : 'Hide Region info');\n   },\n   style: {\n     padding: '0',\n     margin: '0',\n     backgroundColor: '#ffffff00', // Completely transparent background\n     color: '#000000', //Set the text color to black, which can be changed as needed\n     fontSize: '12px', // Font size, can be adjusted as needed\n     border: '0px solid' // Remove border\n   }\n});\n\n\n//Define a function to update the panel to display the clicked characteristic attributes when the map is clicked.\nfunction showFeatureInfo(coords) {\n   var point = ee.Geometry.Point([coords.lon, coords.lat]);\n   var feature = westbank.filterBounds(point).first();\n\n   feature.evaluate(function(feature) {\n     if (feature) {\n       // Clear old attribute information\n       infoPanel.clear();\n\n       // Iterate through the properties of the feature, create a UI element for each property and add it to the panel\n       var table = ui.Panel({\n         layout: ui.Panel.Layout.flow('vertical'),\n         style: {margin: '0 -8px'}\n       });\n\n       Object.keys(feature.properties).forEach(function(key) {\n         var value = feature.properties[key];\n         var row = ui.Panel({\n           layout: ui.Panel.Layout.flow('horizontal'),\n           style: {\n             border: '1px solid black',\n             textAlign: 'left',\n             padding: '2px'\n           }\n         });\n\n         var labelKey = ui.Label({\n           value: key + ':',\n           style: {margin: '0 4px', fontWeight: 'bold', width: 'auto', padding: '2px'}\n         });\n\n         var labelValue = ui.Label({\n           value: value.toString(),\n           style: {margin: '0 4px', width: 'auto', padding: '2px'}\n         });\n\n         row.add(labelKey);\n         row.add(labelValue);\n         table.add(row);\n       });\n\n       infoPanel.add(table);\n     }\n   });\n}\n\n//Set the map click event listener\nMap.onClick(showFeatureInfo);\n\n//Create a panel to hold the information panel and switch button\nvar mappanel = ui.Panel({\n   layout: ui.Panel.Layout.flow('vertical'),\n   style: {position: 'bottom-left'}\n});\n\n//Add buttons and information panels to the panel\nmappanel.add(infotoggleButton);\nmappanel.add(infoPanel);\n\n// Finally, add the panel to the map's sidebar\nMap.add(mappanel);\n\nfunction countAndChartCentroids(centroidLayers) {\n  var years = ee.List.sequence(2017, 2022);\n  var chartData = [];\n\n  // Helper function to handle asynchronous retrieval of size\n  function processYear(yearIndex) {\n    if (yearIndex &lt; years.length().getInfo()) { // Check if there are more years to process\n      var year = years.get(yearIndex).getInfo(); // Get the year as a number\n      var centroids = centroidLayers[year];\n      if (centroids) {\n        centroids.size().evaluate(function(size) {\n          console.log('Year: ' + year + ', Count: ' + size); // Log the count\n          chartData.push({year: year, count: size}); // Push the data to the chart data array\n          processYear(yearIndex + 1); // Recursively process the next year\n        });\n      } else {\n        console.log('Year: ' + year + ', Count: 0'); // Log and handle undefined years\n        chartData.push({year: year, count: 0}); // Push zero count\n        processYear(yearIndex + 1); // Recursively process the next year\n      }\n    } else {\n      // All years have been processed, now create and print the chart\n      chartData = chartData.sort(function(a, b) { return a.year - b.year; }); // Sort the chart data\n      var chart = ui.Chart.array.values(chartData.map(function(item) { return item.count; }), 0, chartData.map(function(item) { return item.year; }))\n        .setChartType('ColumnChart')\n        .setOptions({\n          title: 'Number of Centroids Per Year',\n          hAxis: {title: 'Year'},\n          vAxis: {title: 'Number of Centroids'},\n          legend: {position: 'none'}\n        });\n      panel.widgets().add(chart);\n      currentWidgets.push(chart);\n    }\n  }\n  processYear(0); // Start processing from the first year\n}\n\n// ---------------------------------------------------------------------------------\n// End of part5\n// ---------------------------------------------------------------------------------"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "New Israeli Settlement Identification in the West Bank",
    "section": "",
    "text": "Broken homes\nData source\nHow Israeli settlers are expanding illegal outposts amid Gaza war\nHow the political maps of Israel and Palestine have changed\nMapping Israeli occupation"
  }
]